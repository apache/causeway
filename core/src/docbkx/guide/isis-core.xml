<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"file:./src/docbkx/dtd-4.5/docbookx.dtd">
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->
<book>
  <bookinfo>
    <title><?eval ${docbkxGuideTitle}?></title>

    <subtitle><?eval ${docbkxGuideSubTitle}?></subtitle>

    <releaseinfo><?eval ${project.version}?></releaseinfo>

    <authorgroup>
      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>

      <author>
        <firstname>Robert</firstname>

        <surname>Matthews</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para><emphasis>Apache Isis</emphasis> is designed to allow programmers
    rapidly develop domain-driven applications following the <ulink
    url="http://en.wikipedia.org/wiki/Naked_Objects">Naked Objects</ulink>
    pattern. It is made up of a core framework that supports supports various
    viewers, along with <acronym>API</acronym>s and implementations relating
    to security, the programming model, the runtime (persistence) and profile
    stores (user preferences). <emphasis>Apache Isis</emphasis> is hosted at
    the <ulink url="http://incubator.apache.org/isis">Apache
    Foundation</ulink>, and is licensed under <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Software
    License v2</ulink>.</para>

    <sect1>
      <title>Who this Guide is For</title>

      <para>This guide is written for programmers looking to understand how
      the core framework of <emphasis>Apache Isis</emphasis> fits together,
      including an understanding of its core <acronym>API</acronym>s. It is
      divided into the following parts/chapters:<itemizedlist>
          <listitem>
            <para>Architectural Overview</para>

            <para>The introductory chapter discusses some of the main
            architecture elements of the framework's design, distinguishing
            and explaining the reason for the applib, the core modules, the
            viewers, and the main <acronym>API</acronym>s exposed by the
            core.</para>
          </listitem>

          <listitem>
            <para>Chapters for each of core modules</para>

            <para>This part of the guide goes through each of the modules that
            make up the core framework. We also identify the main
            <acronym>API</acronym>s exposed by the core: security, programming
            models, and runtime.</para>
          </listitem>
        </itemizedlist></para>

      <para>You'll note that we <emphasis>don't</emphasis> describe the
      implementations of these <acronym>API</acronym>s; for these see their
      respective guides. Notably, that means that we don't describe how to
      actually deploy an Isis application here, because that depends upon the
      runtime/viewer in use. See the relevant runtime documentation for
      details.</para>

      <para>You'll also find that <emphasis>this</emphasis> guide (the core
      documentation) does not cover the programming model. Rather, it explains
      why we have an applib in the first place. For details of the programming
      guide (that is, how to actually write <emphasis>Isis</emphasis>
      applications) you should look to the applib (application library)
      documentation. Meanwhile, the programming model guide describe how to
      customize the default programming model to your own ends.</para>
    </sect1>

    <sect1>
      <title>Abbreviations used in this Guide</title>

      <para><emphasis>Apache Isis</emphasis> is built using Maven, which
      identifies every module with a groupId, an artifactId, a version, and a
      type. These are called the Maven <emphasis>co-ordinates</emphasis>. In
      this guide we identify each module using notation
      <package>(groupId:artifactId)</package>; you should assume that the
      <emphasis>version</emphasis> is the latest version, and the
      <emphasis>type</emphasis> is the default JAR artifact<footnote>
          <para>Maven modules can create other artifacts too, such as a test
          JAR artifact. This would be indicated with a type of test-jar. But
          the default artifact is a regular JAR.</para>
        </footnote>. Hence <package>(org.apache.isis:core)</package> is the
      Maven module with a <emphasis>groupId</emphasis> of
      <package>org.apache.isis</package> and an
      <emphasis>artifactId</emphasis> of <package>core</package>.</para>

      <para>As a further convenience, we use "oai" as an abbreviation for
      <package>org.apache.isis</package>. Hence
      <package>(oai.runtimes:dflt)</package> refers to the default runtime
      module.</para>

      <para>In this guide we also use the "oai" abbreviation within package
      names. For example,
      <package>oai.core.runtime.authentication.AuthenticationManager</package>
      is an abbreviation of
      <package>org.apache.isis.core.runtime.authentication.AuthenticationManager</package>.</para>
    </sect1>
  </preface>

  <chapter id="chp.Intro">
    <title>Architectural Overview</title>

    <abstract>
      <para>What's in this guide, it's relationship to the applib
      documentation.</para>
    </abstract>

    <para><emphasis>Apache Isis</emphasis> is a full-stack open source
    application development framework, designed to let you rapidly develop
    enterprise business applications following a domain-driven philosophy.
    Developing an application in <emphasis>Isis</emphasis> is - at least
    initially - about focusing on the bit that matters to the business, the
    core domain logic.</para>

    <sect1>
      <title>Hexagonal Architecture</title>

      <para><emphasis>Apache Isis</emphasis>' architecture is a variant of the
      typical <ulink
      url="http://xunitpatterns.com/Layered%20Architecture.html">layered
      architecture</ulink>, called the <ulink
      url="http://alistair.cockburn.us/Hexagonal+architecture">hexagonal
      architecture</ulink>. Like the layered architecture, the hexagonal
      architecture distinguishes between the user interface layer, the
      persistence (or infrastructure) layer, and the domain layer.
      <emphasis>Apache Isis</emphasis>' version of this architectural style is
      shown below.</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="../../../../src/site/resources/images/HexagonalArchitectureOverview.png"
                     scale="45" />
        </imageobject>
      </mediaobject>

      <para>The viewer modules constitute the presentation layer; these are
      the means by which the end-user initiates an interaction with the domain
      objects. The interaction is not directly with the domain objects,
      though; instead think of the viewers as interacting through a "port"
      into the hexagon. The <emphasis>Isis</emphasis> framework then adapts
      this interaction for the domain objects. Indeed, another name for the
      hexagonal architecture is the "ports and adapters" architecture.</para>

      <para>As the domain objects are called, they are likely to interact with
      other services. The most obvious of these is an interaction with the
      persistence layer, either in terms of an update to themselves or the
      creation/update or deletion of other objects. Again, though, this isn't
      direct; instead the framework mediates/adapts to the configured
      persistence mechanism.</para>

      <para>Alternatively, though, the domain objects may interact with other
      domain services. These services are specific to the application in
      question, for example an email service, to publish an event, to generate
      a <acronym>PDF</acronym>, to submit an order via a
      <acronym>SOAP</acronym> web service etc. Here the framework is much less
      involved; it merely will automatically inject any registered domain
      services directly into domain objects in order that they can invoke the
      service.</para>

      <para>In order to support the interactions from the viewer to the domain
      objects, and from the domain objects to the persistence mechanism, the
      framework itself also calls out to other modules. The progmodel
      <acronym>API</acronym> defines the programming conventions for the
      domain objects; these conventions are used to build up a metamodel. Some
      of these conventions depend on annotations, hence these dependency from
      domain objects to the applib (application library) module which defines
      such things. It's important to note that this is the only dependency
      from domain objects to the framework, meaning that the domain objects
      are basically pojos++. The other major <acronym>API</acronym> called by
      the framework in order to do its job is the security
      <acronym>API</acronym>, which is used for authentication and
      authorization.</para>

      <para>In the diagram you'll also see mention of the "default runtime".
      In fact <emphasis>Apache Isis</emphasis> supports multiple runtimes. The
      <emphasis>default runtime</emphasis> is reasonably heavyweight
      implementation that supports defines a persistence
      <acronym>API</acronym>, but also has support for remoting for
      client/server deployments (whereby the server is configured for
      persistence but the client's "persistence mechanism" is in fact the
      proxy to the server). The default runtime also supports the concept of
      profilestores, allowing user preferences to be stored and retrieved by
      viewers. Finally, the default runtime defines a pluggable bytecode
      enhancement <acronym>API</acronym>, allowing for transparent lazy
      loading and object dirtying.</para>

      <para>The default runtime is not the only runtime, however. One other
      runtime supported is an "embedded runtime", allowing the embedding of
      the Isis metamodel in any arbitrary application, for example a Maven
      plugin. But we also expect to develop other - full-stack but more
      lightweight - runtimes in the future. One such that is planned is to use
      <ulink url="http://jcp.org/en/jsr/detail?id=299">CDI (JSR-299)</ulink>
      for wiring, using <ulink url="http://db.apache.org/jdo/javadoc.html">JDO
      3.0</ulink> for the persistence <acronym>API</acronym>.</para>
    </sect1>

    <sect1>
      <title>Core Framework</title>

      <para>The core of <emphasis>Apache Isis</emphasis> is, well, the core
      modules. These consist of a set of Maven modules grouped under a parent
      module whose Maven co-ordinates are
      <package>(org.apache.isis:core)</package>.</para>

      <para>Each of the core modules has a Maven co-ordinate of
      <package>(org.apache.isis.core:xxx</package>), where
      <emphasis>xxx</emphasis> is one of:</para>

      <itemizedlist>
        <listitem>
          <para>test support</para>

          <para>The <emphasis>testsupport</emphasis> module holds helper
          classes to support writing unit tests in either JUnit or
          JMock.</para>
        </listitem>

        <listitem>
          <para>commons</para>

          <para>The <emphasis>commons</emphasis> module provides a set of
          common utilities and language extensions for use across the rest of
          the framework.</para>
        </listitem>

        <listitem>
          <para>metamodel</para>

          <para>The <emphasis>metamodel</emphasis> module defines the
          interfaces and classes which describe the structure of the domain
          objects. The most obvious use of the metamodel is by the viewer
          modules which use it in order to know how to render the user
          interface. It is also used by some of the runtime/persistence
          implementations.</para>
        </listitem>

        <listitem>
          <para>progmodel</para>

          <para>The <emphasis>progmodel</emphasis> module provides a set of
          reusable elements that are used to build up the metamodel. Some of
          these depend upon annotations/interfaces in the
          <emphasis>applib</emphasis> module, others merely define a
          programming convention.</para>
        </listitem>

        <listitem>
          <para>runtime</para>

          <para>The <emphasis>runtime</emphasis> module defines security
          <acronym>API</acronym> (authentication and authorization) as well as
          a number of other lesser <acronym>API</acronym>s and implementations
          that are likely to be of use by most runtime implementations.</para>
        </listitem>

        <listitem>
          <para>webapp</para>

          <para>The <emphasis>webapp</emphasis> module provides a number of
          supporting filters, servlets and other classes for use by any
          webapp-based viewer.</para>
        </listitem>
      </itemizedlist>

      <para>These modules are covered more extensively in <xref
      linkend="prt.CoreModules" />.</para>
    </sect1>

    <sect1>
      <title>Core <acronym>API</acronym>s</title>

      <para>Across the core modules a number of key <acronym>API</acronym>s
      are defined.</para>

      <itemizedlist>
        <listitem>
          <para>programming model <acronym>API</acronym></para>

          <para>The <emphasis>core metamodel</emphasis> module defines the
          <classname>oai.core.metamodel.progmodel.ProgrammingModel</classname>
          interface, which defines the rules and conventions that constitute
          the programming model.</para>
        </listitem>

        <listitem>
          <para>security <acronym>API</acronym></para>

          <para>The <emphasis>core runtime</emphasis> module defines a
          security <acronym>API</acronym> (specifically,
          <package>oai.core.runtime.authentication.AuthenticationManager</package>
          and
          <package>oai.core.runtime.authorization.AuthorizationManager</package>)
          as well as a number of other lesser <acronym>API</acronym>s and
          implementations that are likely to be of use by most runtime
          implementations.</para>
        </listitem>

        <listitem>
          <para>runtime (persistence) <acronym>API</acronym></para>

          <para>The responsibility of the runtime - broadly speaking - is to
          perform object lifecycle management, persistence and (optionally)
          client/server remoting. Runtimes may also offer other services, such
          as user preference (or profile) management.</para>

          <para>The runtime is not an <acronym>API</acronym> per-se, but
          rather represents the environment in which the other functionality
          provided by the <emphasis>Isis</emphasis> framework is called.
          <emphasis>Isis</emphasis> has two runtime implementations:</para>

          <itemizedlist>
            <listitem>
              <para>the <emphasis>default runtime</emphasis>
              <package>(oai.core.runtimes:dflt)</package> that supports all of
              the above (lifecycle, persistence, remoting and
              profiles).</para>

              <para>A key part of the design of the default runtime is the
              <package>oai.runtimes.dflt.runtime.context.IsisContext</package>
              interface, which is used to obtain the current session<footnote>
                  <para>This interface is somewhat akin to <ulink
                  url="http://docs.jboss.org/hibernate/core/3.3/reference/en/html/tutorial.html">HibernateUtil</ulink>
                  class used in Hibernate.</para>
                </footnote>.</para>
            </listitem>

            <listitem>
              <para>the <emphasis>embedded runtime</emphasis>
              <package>(org.apache.isis.core.runtimes:embedded)</package>, to
              allow the <emphasis>Isis</emphasis> metamodel to be embedded
              within otherwise bespoke applications, and in utilities such as
              Maven plugins.</para>
            </listitem>
          </itemizedlist>

          <para>The intent is that other runtimes implementations (eg using
          CDI, JDO 3.0 etc) will be supported in the future.</para>
        </listitem>
      </itemizedlist>
    </sect1>

    <sect1>
      <title>Viewers</title>

      <para>The viewers can be thought of as the outermost layer of
      <emphasis>Isis</emphasis>, and calls upon the services of the core
      framework and the configured runtime.</para>

      <para>At the time of writing, all viewers have a dependency on the
      <emphasis>default runtime</emphasis>, because this is the only runtime
      available. In the future we expect that this will be decoupled so that
      viewers can run against multiple different runtime
      implementations.</para>

      <para>Slightly confusingly, the <emphasis>default runtime</emphasis>
      does also provide the facility to "launch" viewers, meaning that for
      bootstrapping purposes at least the runtime calls the viewer rather than
      the other way around. In order to support this, the viewer
      implementation must provide an implementation of the runtime's
      <package>oai.runtimes.dflt.runtime.viewer.IsisViewerInstaller</package>
      interface. You'll see that the <acronym>DnD</acronym> viewer does do
      this, but the Scimpi and Wicket viewers do not. However, once the viewer
      is "up and running", the calls are strictly from the viewer to the
      metamodel and runtime.</para>
    </sect1>

    <sect1>
      <title>Maven Modules and Conventions</title>

      <para><emphasis>Apache Isis</emphasis> is a large framework consisting
      of multiple modules. In order to make it easier to navigate, you'll find
      that we've aligned Maven module Ids with package names. For
      example:</para>

      <itemizedlist>
        <listitem>
          <para>the <emphasis>core metamodel</emphasis> module is
          <package>(oai.core:metamodel)</package>; all classes in this module
          reside in the <package>oai.core.metamodel</package> package (or in
          subpackages)</para>
        </listitem>

        <listitem>
          <para>the <emphasis>applib</emphasis> module is
          <package>(oai:applib)</package>; all classes in this module reside
          in <package>oai.applib</package> package (or in subpackages).</para>
        </listitem>
      </itemizedlist>

      <para>We have also grouped modules of the same nature/interface to have
      a common parent. For example:</para>

      <itemizedlist>
        <listitem>
          <para><package>(oai:viewers)</package> is the parent of
          <package>(oai.viewers:dnd)</package> and
          <package>(oai.viewers:html)</package> modules</para>
        </listitem>

        <listitem>
          <para><package>(oai:security)</package> is the parent of
          <package>(oai.security:dflt)</package> and
          <package>(oai.security:ldap)</package> modules</para>
        </listitem>
      </itemizedlist>

      <para>There is also a top-level "parent" module,
      <package>(oai:isis-parent)</package>. This is used to define common
      build/plugin dependencies, as well as a number of Maven profiles that
      can be used to build subsets of the modules, and to build the Maven
      website.</para>

      <para>Finally, Isis also has an <package>(oai:release)</package> module.
      The purpose of this module is simply to define a set of
      <emphasis>Isis</emphasis> modules/versions that are compatible with each
      other and thereby constitute a release. These can be imported
      using:</para>

      <programlisting>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.isis&lt;/groupId
    &lt;artifactId&gt;release&lt;/artifactId&gt;
    &lt;version&gt;x.x.x&lt;/version&gt;
    &lt;scope&gt;import&lt;/scope&gt;
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;</programlisting>

      <para>The <emphasis>Isis</emphasis> quickstart archetype makes use of
      the release module in this way (as do the various examples that live in
      <filename>.../trunk/examples</filename>).</para>
    </sect1>
  </chapter>

  <part id="prt.CoreModules">
    <title>Core Framework Modules</title>

    <partintro>
      <abstract>
        <para>The modules that make up the core framework.</para>
      </abstract>

      <para>This part of the guide goes through each of the modules that make
      up the core framework.</para>
    </partintro>

    <chapter>
      <title><emphasis>Test Support</emphasis> Module</title>

      <abstract>
        <para>Classes and interfaces in the
        <package>oai.core.testsupport</package> module.</para>
      </abstract>

      <para>The <emphasis>testsupport</emphasis> module holds helper classes
      to support writing unit tests using either JUnit or JMock. It should
      only ever be added as a dependency with a scope of test:</para>

      <para><programlisting>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.isis.core&lt;/groupId
    &lt;artifactId&gt;testsupport&lt;/artifactId&gt;
    &lt;version&gt;x.x.x&lt;/version&gt;
    <emphasis>&lt;scope&gt;test&lt;/scope&gt;</emphasis>
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;</programlisting></para>

      <sect1>
        <title>JMock Support</title>

        <para>The classes in the <package>oai.core.testsupport.jmock</package>
        package provide convenience adapters for <ulink
        url="http://jmock.org">JMock</ulink>. For example, they provide the
        <classname>MockFixture</classname> interface that allows mocks
        expectations to be managed as fixture objects in their own right
        (thereby making such expectations reusable across tests). They also
        provide subclasses of the <package>org.jmock.Mockery</package> class
        with a number of convenience methods.</para>
      </sect1>

      <sect1>
        <title>JUnit Support</title>

        <para>The classes in the
        <classname>oai.core.testsupport.junit</classname> package provide
        helper classes designed, among other things, to make it easier to
        write value types.</para>
      </sect1>
    </chapter>

    <chapter>
      <title><emphasis>Commons</emphasis> Module</title>

      <abstract>
        <para>Classes and interfaces in the
        <package>oai.core.commons</package> module.</para>
      </abstract>

      <para>The core commons module provides a set of common utilities for use
      across the rest of the framework. It also defines a number of small,
      mostly internal, <acronym>API</acronym>s.</para>

      <para>Generally it shouldn't be necessary to add an explicit dependency
      to the <emphasis>commons</emphasis> module, because it will be depended
      upon transitively by other modules in <package>oai.core</package>.
      </para>

      <sect1>
        <title>Package Dependencies / Architectural Layering</title>

        <para>The packages that reside within commons have the following
        dependencies:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/common/composition-perspective.png"
                       scale="60" />
          </imageobject>
        </mediaobject>

        <para>The relatively small number of dependencies between these
        packages shows the extent to which the utility classes in common are
        independent of each other.</para>

        <para>Alternatively these packages can be viewed as layers:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/common/architecture-perspective.png"
                       scale="60" />
          </imageobject>
        </mediaobject>
      </sect1>

      <sect1>
        <title>APIs</title>

        <sect2>
          <title><classname>Component</classname> and
          <classname>Installer</classname> <acronym>API</acronym></title>

          <para><emphasis>Isis</emphasis> is a modular framework, and the
          <classname>Component</classname> interface (in
          <package>oai.core.commons.components</package> package) represents
          this abstraction. For example, an authentication manager is a
          <classname>Component</classname>, and so too is an adapter map (for
          tracking object identities).</para>

          <para><classname>Component</classname> has three subinterfaces to
          represent different scopes (or lifetimes) of component instances,
          namely:</para>

          <itemizedlist>
            <listitem>
              <para> <classname>ApplicationScopedComponent</classname>, for
              components that exist for the duration of the application</para>
            </listitem>

            <listitem>
              <para><classname>SessionScopedComponent</classname> , for
              components that are created a-new for each session, and</para>
            </listitem>

            <listitem>
              <para><classname>TransactionScopedComponent</classname>, for
              components that are bound to a single transaction.</para>
            </listitem>
          </itemizedlist>

          <para>For webapp/server-based deployments, a session is created for
          each interaction<footnote>
              <para>Just like JPA or Hibernate sessions.</para>
            </footnote>. There is typically just one transaction per
          session.</para>

          <para>For client/standalone deployments, the session lasts for the
          duration of the application, and so is one-to-one with the
          application scope. For these cases a transaction is used to wrap
          each client/server interaction<footnote>
              <para>Strictly speaking, this is a statement about how the the
              <emphasis>default runtime</emphasis> implementation works. Other
              runtimes could conceivably take a different approach. If you are
              only intending to use webapp-based viewers, then don't worry
              about it... <emphasis>Isis</emphasis> works similarly to
              JPA/Hibernate.</para>
            </footnote>.</para>

          <para>Closely related to <classname>Component</classname> is the
          <classname>Installer</classname> interface, which acts as a
          <classname>Component</classname> factory. Each Installer provides a
          type (a string) and a name (also a string), and the combination of
          (type, name) is expected to be unique. For example, the DnD viewer
          has a type of "viewer" and a name of "dnd".</para>

          <para>This (type, name) combination is used to determine the
          configuration files that are searched for when the
          <classname>Component</classname> is created. Each
          <classname>Component</classname>'s <classname>Installer</classname>
          will search for at least two property files:
          <filename>type.properties</filename> and
          <filename>type_name.properties</filename>. For example, the DnD
          viewer will search for both <filename>viewer.properties</filename>
          and also <filename>viewer_dnd.properties</filename> file<footnote>
              <para>In fact, it is possible for an
              <classname>Installer</classname> to nominate additional property
              files; this is sometimes appropriate where a
              <classname>Component</classname> does double-duty and plays more
              than one role. At the time of writing this capability was only
              used by the components that install client/server remoting for
              the <emphasis>default runtime</emphasis> module.</para>
            </footnote>. An Installer can also indicate whether a missing
          config file should be treated as an error or can be ignored
          (generally the latter).</para>
        </sect2>

        <sect2 id="sec.ConfigurationApi">
          <title><classname>IsisConfiguration</classname> and
          <classname>IsisConfigurationBuilder</classname>
          <acronym>API</acronym></title>

          <para>The <classname>IsisConfigurationBuilder</classname> (in
          <package>oai.core.commons.config</package> package) is used to hold
          the "current" configuration; as (the
          <classname>Installer</classname> for)
          <classname>Component</classname>s are loaded each indicates the
          property file(s) to load, and these are used to update the current
          configuration held within
          <classname>IsisConfigurationBuilder</classname>. The "current"
          configuration is initially just the properties in the
          <filename>isis.properties</filename> file (see <xref
          linkend="sec.ResourceStreamApi" /> for details on where this file is
          actually loaded from) .</para>

          <para>When the <classname>Component</classname> is actually
          instantiated, it is handed an immutable
          <classname>IsisConfiguration</classname> that can be thought of as a
          snapshot of the set of properties held by the
          <classname>IsisConfigurationBuilder</classname>. A consequence of
          this design is that different <classname>Component</classname>s will
          have references to different
          <classname>IsisConfiguration</classname> objects; though all should
          always have access to "their" properties.</para>

          <para>Using properties specified in the configuration files is done
          by get the <classname>IsisConfiguration</classname> singleton from
          the context and using one of the lookup methods to get a value, as
          the example below shows. The <literal
          moreinfo="none">Configuration.ROOT</literal> constant provides the
          base property name ("isis."). If no value is found with the
          specified property name exists then null (or 0 or false) will be
          returned.</para>

          <programlisting format="linespecific">String formatRequired = getConfiguration().getString(Configuration.ROOT + "value.format.date");</programlisting>
        </sect2>

        <sect2>
          <title
          id="sec.ResourceStreamApi"><classname>ResourceStreamSource</classname>
          <acronym>API</acronym></title>

          <para>The <classname>ResourceStreamSource</classname> interface (in
          <package>oai.core.commons.resource</package> package) is an
          abstraction over locating resource files. It is used predominantly
          to locate configuration files (see <xref
          linkend="sec.ConfigurationApi" />), with implementations to load
          from the config directory or from the classpath.</para>

          <para>Different implementations of
          <classname>IsisConfigurationBuilder</classname> use
          <classname>ResourceStreamSource</classname> in order to search for
          config files in specific locations. In principle it would be
          straightforward to write a new implementation of
          <classname>ResourceStreamSource</classname> that loads config files
          from some other location (eg LDAP, the Windows registry or a
          database) and then write a new
          <classname>IsisConfigurationBuilder</classname> to use it.</para>
        </sect2>

        <sect2>
          <title>Encoding <acronym>API</acronym></title>

          <para>The <package>oai.core.commons.encoding</package> package
          provides a number of classes to support the custom serialization of
          elements of any element:</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/common/encoding-classdiagram.png"
                         scale="30" />
            </imageobject>
          </mediaobject>

          <para>The <classname>DataInputExtended</classname> and
          <classname>DataOutputExtended</classname> interfaces are
          straightforward extensions of
          <classname>java.io.DataInput</classname> and
          <classname>java.io.DataOutput</classname> respectively, simply
          adding the capability to serialize arrays of primitives. The
          <classname>DataInputStreamExtended</classname> and
          <classname>DataOutputStreamExtended</classname> implement these
          interfaces, providing the ability to read from/write to an
          underlying <classname>java.io.InputStream</classname>.</para>

          <para>Finally, the <classname>Encodable</classname> interface
          defines a contract for objects to write themselves to a
          <classname>DataOutputStreamExtended</classname>, with an implied
          contract that they can be re-constructed from a corresponding
          <classname>DataInputStreamExtended</classname>.</para>

          <para>The primary usage of the encoding API is to enable
          client/server remoting, as supported by the <emphasis>default
          runtime</emphasis> implementation. However, it is also used in order
          to create <classname>Memento</classname>s of domain objects (again,
          a capability of the <emphasis>default runtime</emphasis>). This is
          used by some viewers in order to maintain a handle on transient
          (not-yet-persisted) objects.</para>
        </sect2>

        <sect2>
          <title><classname>AuthenticationSession</classname>
          Definition</title>

          <para>The <classname>AuthenticationSession</classname> interface (in
          the <package>oai.core.commons.authentication</package> package)
          provides a representation of an authenticated user within the
          system. </para>

          <para>Also worth mentioning is the utility class
          <classname>AuthenticationSessionUtils</classname> can be used to
          create an <classname>oai.applib.security.UserMemento</classname>,
          which is the corresponding type within the applib (that is, the
          identity of the authenticated user as the domain objects understand
          it).</para>

          <para>The interface to actually authenticate users and create
          <classname>AuthenticationSession</classname>s - namely
          <classname>AuthenticationManager</classname> - is defined in the
          <emphasis>core runtime</emphasis> module (see <xref
          linkend="chp.Runtime" />). This shouldn't be confused with
          <classname>AuthenticationSessionProvider</classname> which merely
          returns the current <classname>AuthenticationSession</classname>
          <emphasis>if one exists</emphasis>.</para>
        </sect2>

        <sect2>
          <title><classname>Debuggable</classname>
          <acronym>API</acronym></title>

          <para>The <classname>Debuggable</classname> interface(in the
          <classname>oai.core.commons.debug</classname> package) is used by
          some <classname>Component</classname>s in order to build structured
          string representations of themselves for debug purposes. A good
          example is the debug menu options available within the DnD
          viewer.</para>
        </sect2>

        <sect2>
          <title>Hamcrest <classname>Matcher</classname>s</title>

          <para>The <classname>IsisMatchers</classname> class (in the
          <classname>oai.core.commons.matchers</classname> package) provides a
          collection of <ulink url="http://hamcrest.org">Hamcrest
          </ulink><classname>Matcher</classname>s for use in both tests and
          also production code.</para>
        </sect2>

        <sect2>
          <title><classname>Ensure</classname> API</title>

          <para>The <classname>Ensure</classname> class (in the
          <package>oai.core.commons.ensure</package> package) allows
          assertions to be made about arguments, state or general context, and
          uses Hamcrest <classname>Matcher</classname>s to express those
          assertions.</para>
        </sect2>
      </sect1>
    </chapter>

    <chapter id="chp.MetaModel">
      <title><emphasis>Metamodel</emphasis> Module</title>

      <abstract>
        <para>Classes and interfaces in the
        <package>oai.core.metamodel</package> module.</para>
      </abstract>

      <para></para>

      <para></para>

      <sect1>
        <title></title>

        <para></para>

        <para></para>

        <para>The core <emphasis>metamodel</emphasis> module defines the
        interfaces and classes that make up the <emphasis>Apache
        Isis</emphasis> metamodel. The metamodel is used in numerous ways,
        including:</para>

        <itemizedlist>
          <listitem>
            <para>by viewers to obtain information about the domain objects,
            so that they can be rendered in a generic object-oriented user
            interface;</para>
          </listitem>

          <listitem>
            <para>by object stores (the default and some of the alternatives)
            to determine which data is to be persisted;</para>
          </listitem>

          <listitem>
            <para>by remoting, to marshall domain objects automatically
            between different tiers;</para>
          </listitem>

          <listitem>
            <para>by the core runtime, to provide the ability to provide XML
            Snapshots (through the <classname>XmlSnapshot</classname> utility
            class). The metamodel module does not itself define the
            programming model conventions; that is the responsibility of the
            core progmodel.</para>
          </listitem>
        </itemizedlist>

        <para></para>
      </sect1>

      <sect1>
        <title>Package Dependencies / Architectural Layering</title>

        <para></para>

        <para></para>

        <screenshot>
          <screeninfo>Top-level Architecture Diagram with SpecLoader
          expanded</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/metamodel/architecture-diagram-top-level-with-specloader-expanded.png"
                         scale="60" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>

        <screenshot>
          <screeninfo>Composition Diagram</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/metamodel/composition-diagram-top-level.png"
                         scale="60" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>
      </sect1>

      <sect1>
        <title>Reflection</title>

        <para></para>

        <para></para>

        <para>To make the domain objects useful within the framework the
        objects' public interfaces must be exposed. Reflection capabilities
        are used to determine what fields or properties an object has, what
        behaviour it can offer, and to find other information such as the
        object's title, a suggested order of it fields, when the actions can
        or can't be used. The details about this interface are recorded in an
        instance of <classname>ObjectSpecification</classname>. As each class
        of domain object is loaded into the system introspection is performed
        and an instance of <classname>ObjectSpecification</classname> is
        generated. That specification object is subsequently available from
        any object adapter (using the
        <methodname>ObjectAdapter.getSpecification</methodname> method) for
        that type of domain object; or it can be retrieved directly, by name
        or class, from the <classname>ObjectSpecificationLoader</classname>
        instance (obtained from the <classname>Isis</classname>
        repository).</para>

        <para>Through an object's <classname>ObjectSpecification</classname>
        instance the rest of the NOF can find out the fields that an object
        has, the methods it offers, the title to use to identify the object,
        and other details about the object. These are used normally used by
        the implementations of ObjectAdapter etc when another component ask
        the adapter for details about another object. For example For example
        the statement <code>adapter.getField(no.getFields()[0])</code> would
        retrieve the first field in the domain object held by the Isis
        referenced by <code>adapter</code>.</para>

        <sect2>
          <title>How it Works</title>

          <para>When a domain object is used within the NOF the
          <classname>ObjectSpecificationLoader</classname> instance is asked
          for the <classname>ObjectSpecification</classname> for the domain
          object's class (by name or <classname>java.lang.Class</classname>
          object). For performance reasons these objects are normally cached
          and if the class has previously been introspected then the cached
          version would be returned. The first time that class is requested
          however the loader is responsible for performing the introspection
          and creating a complete
          <classname>ObjectSpecification</classname>.</para>

          <para>For each field that the reflector recognises the loader
          creates either a <classname>OneToOneAssociation</classname> object
          for a value field or a reference field, or a
          <classname>OneToManyAssociation</classname> object for a collection
          or array. Using the field objects the NOF can access or change the
          values and references in the domain object. The fields can also be
          used by the NOF to find out the field name, if the fields are
          visible and whether it can be modified.</para>

          <para>For each action method that the reflector recognises the
          loader must create an <classname>Action</classname> object. Using
          the action object the NOF can invoke the method on the domain
          object. The action object also can be used by the NOF to find out
          the action's name, whether it is visible and whether it can be
          executed.</para>

          <para>In addition to the fields and actions the specification must
          can also: return the various forms of class name (singular; plural;
          short; and full); retrieve a title from, or generate a title for,
          the domain object; flag the type of object (abstract, lookup,
          object, value, and whether persistable); refer to its superclass,
          any inteferfaces it implements and any subclasses; and allow objects
          to marked/cleared as being dirty.</para>
        </sect2>

        <sect2>
          <title>Installation</title>

          <para>To set up the NOF to use a reflection mechanism the
          <classname>Isis</classname> repository must be given a
          <classname>ObjectSpecificationLoader</classname> instance before the
          repository is initialised. This can be done using the repository's
          static <methodname>setSpecificationLoader</methodname> method. For
          example, the following sets the NOF up to use the basic
          reflector.</para>

          <programlisting>ObjectSpecificationLoader loader = new
        JavaSpecificationLoader();
        Isis.setSpecificationLoader(loader);</programlisting>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Reflector</title>

        <para></para>

        <para>The reflector provides the NOF with two distinct facilities.
        First it provides the framework with a model of the domain objects
        that it will be using, and second, it provides a mechanism for the
        framework and the clients of the framework to access and maniplate the
        domain objects (the framework and its clients should never interact
        with the domain objects directly).</para>

        <para>This section is divided into two. The first part looks at how
        the reflector is used by the framework and its clients, while the
        second part looks at how the reflector itself works and how it can be
        extended.</para>
      </sect1>

      <sect1>
        <title>ObjectAdapter and ObjectSpecification</title>

        <para></para>
      </sect1>

      <sect1>
        <title>Adapters and OIDs</title>

        <para>Isis wrap each domain object in the system. The rest of the
        framework does not normally work with the domain objects directly, but
        via these proxies. The proxies provide access to the tools of the
        reflector by providing a <classname>ObjectSpecification</classname>
        for the object's class and to access additional information about the
        domain object. The specification is accessed via the
        <methodname>getSpecification()</methodname> method and is then used
        with the proxy as a mechanism to access and manipulate the domain
        object. Other key methods on the proxy allow access to the: object
        identifier, via the getOid() method to get its unique OID; version
        information, via <methodname>getVersion()</methodname> to get it
        current Version object; and its lazy loaded state, via the
        <methodname>getResolved()</methodname> state returning the
        <classname>ResolvedSate</classname> object reflecting how complete the
        object is.</para>

        <sect2>
          <title>OIDs</title>

          <para></para>

          <para></para>

          <para>*** An Oid is an object identifier, assigned by the runtime.
          For persisted objects it is value is assigned by the object store,
          but for transient objects the framework still assigns an Oid also
          (and will update the Oid if the object is persisted).</para>

          <para></para>

          <para></para>

          <para>Any domain object that is not a composite part of another
          domain object must have an identity so that the references between
          objects can be persisted for future access and transferred between
          VMs. The OID must be unique so that a one to one mapping can be
          maintained between an <classname>Oid</classname> and a
          <classname>ObjectAdapter</classname>, and hence a domain object.
          Using the OID the client and server can have copies of the same
          objects and identify those objects remotely and persistently. The
          identity is held by the proxy is an <classname>Oid</classname>
          object. The OID for a specific domain object is unique and will not
          change other than when the object is persisted. Until that point it
          has a transient OID that is morphed into the persistent OID when the
          object is persisted. This is so that the transient objects can be
          passed back and forth between client and server, and once persisted
          both ends can match the identity of the previously transient object
          with the identity of the now persistent object.</para>

          <para>When an object is made persistent (typically via the persistor
          and specifically via <classname>OidGenerator</classname>) its OID is
          changed to reflect this and also to allow the persistor to provide
          its own identifier (as is necessary when using natural keys in a
          relational database backend). So the
          <methodname>isTransient()</methodname> state changes from
          <code>true</code> to <code>false</code> while the internal id state
          might be changed. More visibly, the previous state of the OID is
          copied so that <methodname>getPrevious()</methodname> now returns a
          copy of the original OID instead of null and
          <methodname>hasPrevious()</methodname> will return true.</para>

          <para>When a OID with a previous OID is used to retrieve an object
          from the persistor the persistor first checks the OID and if
          <methodname>hasPrevious()</methodname> returns <code>true</code> the
          original tranisent object is retrieved, that object is removed from
          the cache, its OID is updated (via the
          <methodname>copyFrom(Oid)</methodname> method) and then it is
          returned to the cache. This results in the newly persisted object
          having the new persistent OID and it being accessible as such from
          the cache. At this point the original version's transient state will
          no longer be recognised.</para>
        </sect2>

        <sect2>
          <title>ResolveState</title>

          <para></para>

          <para></para>
        </sect2>

        <sect2>
          <title>Version</title>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>ObjectMember hierarchy</title>

        <para></para>
      </sect1>

      <sect1>
        <title>FacetedMethod</title>

        <para>aka ObjectMemberPeer</para>

        <para></para>
      </sect1>

      <sect1>
        <title>Similarity between Properties and Parameters</title>

        <para></para>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>FacetFactory</title>

        <para></para>
      </sect1>

      <sect1>
        <title>MethodFilteringFacetFactory</title>

        <para></para>
      </sect1>

      <sect1>
        <title>MethodPrefixBasedFacetFactory</title>

        <para></para>
      </sect1>

      <sect1>
        <title>PropertyOrCollectionIdentifyingFacetFactory</title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>InteractionAdvisor</title>

        <para></para>

        <para></para>

        <sect2>
          <title>HidingInteractionAdvisor</title>

          <para></para>
        </sect2>

        <sect2>
          <title>DisablingInteractionAdvisor</title>

          <para></para>
        </sect2>

        <sect2>
          <title>ValidatingInteractionAdvisor</title>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>RuntimeContext</title>

        <para></para>
      </sect1>

      <sect1>
        <title>PropertyOrCollectionIdentifyingFacetFactory</title>

        <para></para>
      </sect1>

      <sect1>
        <title>Reflector Properties</title>

        <sect2>
          <title>FacetDecorator</title>

          <para></para>

          <para>*** gonna try to get rid of.</para>

          <para></para>

          <para>The reflector facet-decorators property specifies a list of
          <classname>FacetDecoratorInstaller</classname> objects that should
          be installed and registered with the reflector. These decorators
          decorate specific facets of the metamodel, allowing it change or
          modify their behaviour. This allows us to add internationalization,
          help look up and other features. Although transaction management is
          also achieved by decorating the reflector this is done automatically
          and does not need to be specified using this property. The following
          example adds a single decorator that provide internationalization
          via resource files.</para>

          <programlisting format="linespecific">isis.reflector.facet-decorators=resource-i18n</programlisting>

          <para></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Using the reflector</title>

        <para></para>

        <para>When the framework starts up it is told about the service
        objects that are provided by DOM and any referenced class is then
        introspected to build up the model of the known domain objects. Any
        other domain classes that are subsequently used will also be reflected
        upon as they are used (this will happen when there are classes that
        have no direct references from the service objects, typically because
        the references are for abstract types and not concrete ones). With the
        model in place clients can then determine how to interact with the
        domain model. Each domain class that is in use by the framework has a
        corresponding <classname>ObjectSpecification</classname> detailing the
        properties and structure of the domain class. Properties include the
        classes variouse names (full, short, singular and plural names), a
        description and flags indicating various features. The structure of
        the object includes related classes (superclass, subclasses and
        implemented interfaces), properties and actions. In additions to these
        common elements there are also a set of <classname>Facet</classname>s
        associated with each specification that provide additional information
        about and behaviour for the class.</para>

        <para></para>

        <remark>Classes: MemberIdentifier</remark>

        <sect2>
          <title>Specifications</title>

          <para>The specification is typically retrieved from an adapted
          domain object via the
          <methodname>ObjectAdapter.getSpecification()</methodname> method,
          but can also be looked up via the
          <emphasis>ObjectReflector.loadSpecification()</emphasis> method (for
          a class object or class name) as follows</para>

          <programlisting>ObjectSpecification spec;
spec = IsisContext.getReflector().loadSpecification(Book.class);
String screenName = spec.getSingularName();</programlisting>

          <para></para>
        </sect2>

        <sect2>
          <title>Properties</title>

          <para></para>

          <para></para>

          <para>From the specification an array of every available property
          can be access via the <methodname>getProperties()</methodname>
          method and an individual property can be accessed via the
          <methodname>getProperty(String)</methodname> method, where the sole
          parameter is the the identifier of the property. For the included
          introspector the property identifier will be the name of the
          property method with the <emphasis>get</emphasis> prefix removed,
          and the first character of the remaining string converted to
          lowercase, so <methodname>getCustomerId()</methodname> become
          <emphasis>customerId</emphasis>. Typically the complete list of
          properties is used for things like persistence and remoting, user
          interfaces need to consider what properties they show to avoid
          making hidden or unauthorised properties visible.</para>

          <para>To gather a selective set of properties for a specification
          you can use the .... method.</para>

          <para>All properties detailed are as
          <classname>ObjectAssociation</classname> objects, specifically
          <classname>OneToOneAssociation</classname> and
          <classname>OneToManyAssociation</classname> for value and reference
          objects and collections respectively. Each association object knows
          what type it for (<methodname>getSpecification()</methodname>), can
          provide its name, description and help text, determine whether it
          should be visible and useable, provides various flags indicating its
          usage and provides access to the facets that exist a the property
          level.</para>

          <programlisting>ObjectAssociation[] properties = spec.getProperties();
for (int i = 0; i &lt; properties.length; i++) {
    String name = properties[i].getName();
    boolean mustEnter = properties[i].isMandatory();
    :
    :
}</programlisting>

          <para>To selectively get hold of properties the
          <methodname>getProperties(ObjectAssociationFilter)</methodname>
          method should be used. The
          <classname>ObjectAssociationFilter</classname> class allows us to
          set up a search filter to get properties based on name, type, facet
          etc. Predefined instances and factory methods are available from the
          <classname>Filters</classname> and
          <classname>DynamicFilters</classname> classes or you can extend the
          <classname>ObjectAssociationFilter</classname> class to create your
          own. Two useful predefined versions are the
          <varname>Filters.STATICALLY_VISIBLE</varname> instance and the
          <methodname>DynamicFilters.dynamicallyVisible(ObjectAdapter)</methodname>
          factory method. Using these filters you can find the properties that
          are visible on a particular type and for a particular object, in
          other words excluding those that where hidden during definition
          (using anotations etc) and those that are programatically hidden
          depending on role or state. Typically views are created using only
          dynamically visible properties so hidden fields are not visible and
          do not have any screen space reserved form them. In particular views
          all the possible properties might need space although the final
          propert might not be shown, a good example of this is table views
          where each statically visible property has a column created for it,
          while for each object shown in table only the dynamically visible
          properties for that object are show (ie there may be blank
          cells).</para>

          <para></para>

          <programlisting>ObjectAssociationFilter filter = DynamicFilters.DynamicFilters.dynamicallyVisible(object);
ObjectAssociation[] properties = object.getSpecification().getProperties(filter);
for (int i = 0; i &lt; properties.length; i++) {
    addField(properties[i].getName(), createFieldView(properties[i]));
}</programlisting>

          <para></para>

          <para></para>
        </sect2>

        <sect2>
          <title>Actions</title>

          <para></para>

          <para></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Facets</title>

        <para>*** eliminate overlap with above</para>

        <para></para>

        <para></para>

        <sect2>
          <title>PropertiesAndCollectionsIdentifyingFacet</title>

          <para></para>
        </sect2>

        <sect2>
          <title>InteractionAdvisors</title>

          <para></para>

          <sect3>
            <title>HidingInteractionAdvisor</title>

            <para></para>
          </sect3>

          <sect3>
            <title>DisablingInteractionAdvisor</title>

            <para></para>
          </sect3>

          <sect3>
            <title>ValidatingInteractionAdvisor</title>

            <para></para>

            <para></para>
          </sect3>
        </sect2>
      </sect1>

      <sect1>
        <title>MetaModel Validator</title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>ProgrammingModel API</title>

        <para></para>

        <para><classname>org.apache.isis.core.metamodel.progmodel.ProgrammingModel</classname></para>

        <para></para>

        <para>Isis also allows you to develop your domain application in
        Groovy. This support should be considered experimental for the moment;
        although the viewers and fixtures/in-memory object store work fine, it
        has not been fully tested out with other object stores. Further
        details are available in the
        {{{./support/languages/groovy/index.html}groovy}} module.p</para>

        <para></para>

        <para>x-ref chapter in part 2</para>

        <para></para>
      </sect1>

      <sect1>
        <title>The Dump Utility</title>

        <sect2>
          <title>The Dump Utility</title>

          <para>The <classname>org.apache.isis.core.metamodel.Dump</classname>
          class provides a simple way out outputting the details of adapters
          and specifications. The two <methodname>specification
          </methodname>methods detail the specified
          <classname>ObjectSpecification</classname> as follows:-</para>

          <screen format="linespecific">Full Name: bom.Location
Short Name: Location
Plural Name: Locations
Singular Name: Location

Abstract: false
Lookup: false
Object: true
Value: false
Persistable: User Persistable
Superclass: java.lang.Object
Subclasses: empty
Interfaces: bom.Common
Fields
    OneToOneAssociationImpl@1408a92 [type=VALUE,id=type,label='Type',derived=false,type=Option]
    :
    :</screen>

          <para>The two <methodname>object</methodname> methods detail the
          specified <classname>Isis</classname> object as follows:-</para>

          <screen format="linespecific">Specification: bom.Location
Class: bom.Location
Adapter: org.apache.isis.object.defaults.PojoAdapter
Hash: #dada24
Title: test, Fort Worth
Object: bom.Location@18e4327
OID: OID#2F
State: ResolveState@1e1be92 [name=Resolved,code=PR]
Version: LongNumberVersion#1 20051118-025400170
Icon: null
Persistable: User Persistable</screen>

          <para>The two <methodname>graph</methodname> methods detail the
          specified <classname>Isis</classname> object as follows, showing
          each adapter, it associated objects and values:-</para>

          <screen format="linespecific">PojoAdapter@dada24 [PR:OID#2F,specification=Location,version=LongNumberVersion#1 20051118-025400...
    +--type: POJO BusinessValueAdapter: One
    +--knownas: POJO TextStringAdapter: test
    +--streetaddress: POJO TextStringAdapter: address
    +--city: PojoAdapter@b51404 [PR:OID#C,specification=City,version=LongNumberVersion#1 ...
    |    +--name: POJO TextStringAdapter: Fort Worth
    +--customer: PojoAdapter@92dcdb [PR:OID#1C,specification=Customer,version=LongNumberVers...
    |    +--firstname: POJO TextStringAdapter: Richard
    |    +--lastname: POJO TextStringAdapter: Pawson
    |    +--phonenumbers: VectorCollectionAdapter@1d381d2 [PR:-,specification=Vector,version=...
    : 
    :</screen>

          <para></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>
    </chapter>

    <chapter>
      <title><emphasis>Progmodel</emphasis> Module</title>

      <abstract>
        <para>Classes and interfaces in the
        <package>oai.core.progmodel</package> module.</para>
      </abstract>

      <para></para>

      <sect1>
        <title></title>

        <para></para>

        <para>The core <emphasis>progmodel</emphasis> provides a set of
        reusable elements (implementations of the
        <classname>FacetFactory</classname> API) that can be reused to make up
        a programming model.</para>

        <para>Most of those within this module are in fact used in the default
        programming model, defined by the default progmodel module. They are
        defined within core, however, to allow custom programming models
        (perhaps extending or trimming back the default programming model) to
        be defined.</para>

        <para></para>

        <para></para>

        <screenshot>
          <screeninfo>Architecture Diagram</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/progmodel/architecture-diagram.png"
                         scale="60" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>

        <screenshot>
          <screeninfo>Composition Diagram (facets package)</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/progmodel/composition-diagram-facets-package.png"
                         scale="60" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>

        <para></para>

        <para></para>
      </sect1>

      <sect1 id="i18n-files" label="">
        <title>Internationalization resource files (I18n Facet
        Decorator)</title>

        <sect2>
          <title>Files</title>

          <para>Translated names, descriptions and help text for a specific
          language should be held in a file named in the following
          format:</para>

          <screen format="linespecific">i18n_&lt;language code&gt;_&lt;country code&gt;.properties</screen>

          <para>The language and country codes must reflect the translated
          language are ISO standards and are detailed in the <link
          linkend="locale">Locale section</link>.</para>

          <para>Theses files must be on the root of the class path, otherwise
          they cannot be loaded.</para>
        </sect2>

        <sect2>
          <title>Properties</title>

          <para>Each property can have a line for each of the name,
          description and help text. The format for each is shown
          below.</para>

          <programlisting format="linespecific">&lt;fully qualified class name&gt;.property.&lt;property name&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.property.&lt;property name&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.property.&lt;property name&gt;.help=&lt;translated help&gt;</programlisting>

          <para>The class name must be fully qualified and the property name
          is the short name provided by the reflector. All the values are case
          sensitive. The following shows the translated name and description
          being specified for the property <emphasis>fullName</emphasis>,
          which is defined by the <methodname>getFullName</methodname>
          method.</para>

          <programlisting format="linespecific">example.dom.Contact.property.fullName.name=Nom
example.dom.Contact.property.fullName.description=Le nom complet du client</programlisting>
        </sect2>

        <sect2>
          <title>Collections</title>

          <para><remark>TODO: presumably i18n is supported for collections,
          too?</remark></para>
        </sect2>

        <sect2>
          <title>Actions</title>

          <para>Actions are specified in a similar fashion to properties but
          with the keyword <emphasis>action</emphasis> instead of
          <emphasis>property</emphasis>. Parameters within an action can also
          be translated by inserting <emphasis>parameter</emphasis> and a
          number before the keyword. Each parameter must be numbered to show
          its position, starting from one (1), eg
          <emphasis>parameter1</emphasis>, <emphasis>parameter2</emphasis>
          etc.</para>

          <programlisting format="linespecific">&lt;fully qualified class name&gt;.action.&lt;action name&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.help=&lt;translated help&gt;

&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.help=&lt;translated help&gt;</programlisting>

          <para>The class name must be fully qualified and the action name is
          the short name provided by the reflector. All the values are case
          sensitive. The following shows the translated action name and
          description, and two parameter names being specified for the action
          <emphasis>createPhone</emphasis>, which is defined by the
          <methodname>createPhone</methodname> method.</para>

          <programlisting format="linespecific">example.dom.Contact.action.createPhone.name=Nouveau tlphone
example.dom.Contact.action.createPhone.parameter1.name=Indicatif de zone
example.dom.Contact.action.createPhone.parameter2.name=Nombre
example.dom.Contact.action.createPhone.description=Crez un nouveau tlphone et ajoutez-le au contact actuel</programlisting>

          <para></para>
        </sect2>
      </sect1>
    </chapter>

    <chapter id="chp.Runtime">
      <title><emphasis>Runtime</emphasis> Module</title>

      <abstract>
        <para>Classes and interfaces in the
        <package>oai.core.runtime</package> module.</para>
      </abstract>

      <para>The <emphasis>core runtime</emphasis> module (not to be confused
      with the <emphasis>dflt runtime</emphasis> module) ...</para>

      <para>***</para>

      <para></para>
    </chapter>

    <chapter>
      <title><emphasis>Webapp</emphasis> Module</title>

      <abstract>
        <para>Classes and interfaces in the <package>oai.core.webapp</package>
        module.</para>
      </abstract>

      <para></para>
    </chapter>
  </part>

  <part>
    <title>*** Principles</title>

    <chapter>
      <title>Conventions</title>

      <para>*** change into an appendix?</para>

      <para></para>

      <para></para>

      <para>The <emphasis>Isis</emphasis> framework provides a number of tools
      to help resolve problems and debug the system. These are mainly
      applicable to issues within system code, but some of them can be useful
      when developing applications. The framework provides the
      following:-</para>

      <itemizedlist>
        <listitem>
          <para>Extensive use of logging through the <ulink
          url="http://logging.apache.org/log4j/docs/">Log4j</ulink> framework,
          an open source logging framework made available as part of the
          Apache Jakarta project ;</para>
        </listitem>
      </itemizedlist>

      <para>In addition, the DnD viewer provides debug views that display
      details of components and anything else that implements the
      <classname>DebugInfo</classname> interface. There is further coverage of
      this last feature in the DnD viewer's documentation.</para>

      <para></para>

      <sect1>
        <title>Logging</title>

        <para>Logging using Log4j is used throughout the framework and the
        components the Isis development team have created, and it is
        recommended that you use it too. Logging allows you to look what the
        framework and components have been when you investigate a problem and
        help to identify what parts of the system where doing what before an
        problem arose. Often logging alone is enough to pin point a problem,
        but if not it help you target what to investigate.</para>

        <para>Log4j allows you to log log debug messages, information about
        the system's state, warnings and errors. These events can be displayed
        on the console, written to files, or sent out over the network for
        remote logging. These are output in a user defined format and also can
        be filtered (so only events from certain components are seen). All
        this is configured through a set of properties passed to Log4J.</para>

        <sect2>
          <title>Configuring Logging</title>

          <para>The complete options for outputting and formatting can be
          found in the relavent Log4J documentation (including the API).
          However, it crucial to smooth development of an NOF system that will
          cover some of it here. The NOF configures Log4j using properties
          files and will generally load <filename class="directory"
          moreinfo="none">log4j.properties</filename> or retrieve the
          properties from the that were loaded from <filename
          class="directory" moreinfo="none">isis.properties</filename> after
          that is loaded for framework configuration (these files need to be
          located in the working directory). If you are not using classes
          within the NOF to start the framework then how these properties are
          loaded could vary. The downside of putting the logging properities
          in the framework properties files is that there is no logging until
          it has been loaded. If this is necessary then it is better to use
          the separate properties file.</para>

          <para>The following file, or portion of a file, is a basic
          configuration for logging. It consists of two appenders and a basic
          logging configuration.</para>

          <programlisting format="linespecific">log4j.rootLogger=INFO, Console, File

# The console appender
log4j.appender.Console=org.apache.log4j.ConsoleAppender
log4j.appender.Console.Target=System.out
log4j.appender.Console.layout=org.apache.log4j.PatternLayout
log4j.appender.Console.layout.ConversionPattern=%-5r [%-20c{1} %-10t %-5p]  \t\t%m%n

# The exploration.log file appender
log4j.appender.File=org.apache.log4j.FileAppender
log4j.appender.File.File=exploration.log
log4j.appender.File.layout=org.apache.log4j.PatternLayout
log4j.appender.File.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
log4j.appender.File.Append=false</programlisting>

          <para>The first line sets up logging to show events of level
          <emphasis>INFO</emphasis> and above through the
          <emphasis>Console</emphasis> and <emphasis>File</emphasis>
          appenders, which writes those events to the console and the file
          <filename class="directory"
          moreinfo="none">exploration.log</filename> respectively. The two
          blocks sepcifiy how to write to the console and the file. Other
          appenders can be used to change where the logs are written to. The
          number of appenders specified is unlimited, although there should be
          at least one. The console below (from Eclipse) shows the log. The
          file will contain the same thing although the formatting will be
          slightly different as the conversion pattern for the two appenders
          is different.</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/console-log.png" />
            </imageobject>
          </mediaobject>

          <sect3>
            <title>Logging levels</title>

            <para>The types of events that are logged can be changed. This
            determines how large the files become or how much traffic is put
            over the network, and is reflected in the amount of processing
            that needs to be done to process the events into messages that can
            be written out. Levels in order of increasing verbosity and log
            size, and is decreasing order of severity are:-</para>

            <itemizedlist>
              <listitem>
                <para>OFF - no logging</para>
              </listitem>

              <listitem>
                <para>FATAL - something very serious has happened that
                requires the system to be shut down.</para>
              </listitem>

              <listitem>
                <para>ERROR - something serious has happened that might affect
                any subsequent actions.</para>
              </listitem>

              <listitem>
                <para>WARN - something has not been set up properly, or needs
                attention. Although subsequent action might function
                correctly, they might not function as expected.</para>
              </listitem>

              <listitem>
                <para>INFO - information to the developer about something that
                has taken place.</para>
              </listitem>

              <listitem>
                <para>DEBUG - detailed information for the developer.</para>
              </listitem>
            </itemizedlist>

            <para>So in the above example to increase the logging level to
            debug change the first part of the property to
            <emphasis>DEBUG</emphasis> from <emphasis>INFO</emphasis> as
            below:</para>

            <programlisting format="linespecific">log4j.rootLogger=DEBUG, Console, File</programlisting>

            <para>Logging should almost never be set to off, but should at
            least be set to log the errors (unsing level ERROR). Whilst
            developing we recommend that you set your basic level to INFO and
            switch to DEBUG if you need to investigate something.</para>

            <para>Setting the logging level via the properties file applies
            that level at startup and cannot be changed using the properties,
            ie, that level will be used to filter all logged event while the
            system is running. If you are using the Skylark viewer, however,
            you can use the debug options to change the logging level on the
            client at any time. By using Ctrl-Shift-right-click on the desktop
            you will be shown the debug menu and see the following
            options:-</para>

            <mediaobject>
              <imageobject>
                <imagedata align="left" fileref="images/logging-debug.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>

            <para>The greyed-out option indicates the current level.
            Selectiing one of the other levels will change the logging to that
            level.</para>
          </sect3>

          <sect3>
            <title>Limiting logging by class</title>

            <para>As well as limiting the level of events that are logged, we
            can also specify which classes we are interested in capturing log
            events for. In Log4j events are organised by loggers, which are
            set up programmatically, but as we create a logger for each class
            we talk about classes.</para>

            <para>To change the levels of events captured according to the
            class where the log event was created we can class based
            requirements after the root logger is specified. To set a logging
            level for a class add a property in the form</para>

            <programlisting format="linespecific">log4j.logger.&lt;package to log&gt;=&lt;level for package&gt;
log4j.logger.&lt;class to log&gt;=&lt;level for class&gt;</programlisting>

            <para>Events for the specified packages or class will be logged at
            the specified level, overriding the root level set up first. So
            for example the following configuration:</para>

            <programlisting format="linespecific">log4j.rootLogger=WARN, Console

log4j.logger.org.apache.isis.object=INFO
log4j.logger.org.apache.isis.object.reflect=DEBUG
log4j.logger.org.apache.isis.object.persistence=DEBUG

log4j.logger.org.apache.isis.object.loader.ObjectLoaderImpl=OFF</programlisting>

            <para>will capture warning and errors for all classes (as defined
            by the root logger), and information messages for those classes
            whose package begins with
            <classname>org.apache.isis.object</classname>. In addition those
            classes beginning with <classname>org.apache.isis.object.reflect
            </classname>or
            <classname>org.apache.isis.object.persistence</classname> will
            have their debug events captured as well. Finally, the class
            <classname>ObjectLoader</classname> will have all of its events
            ignored.</para>

            <para>It is important to make use of this feature when using the
            Skylark viewer as it logs events about it rendering. In Java
            rendering the screen (via the
            <methodname>paint(Graphics)</methodname> method) happens very
            often and can cause the logs to be swamped with superflous events.
            The logger for these events are prepended with the text 'ui.' so
            we can disable all of these events across all the viewing classes
            by adding the following to the properties:</para>

            <programlisting format="linespecific">log4j.logger.ui=OFF</programlisting>
          </sect3>

          <sect3>
            <title>Writing XML log files</title>

            <para>By writing out the logs to a file in XML rather than as text
            allows you to look at the log using Chainsaw, a Log4j viewer. This
            tool allows you to quickly look at events in specific classes and
            hide events that are of no interest by setting up simple
            conditions.</para>

            <para>To write out an XML file the same appender as before is
            used, but the layout is changed. The following configuration logs
            all events (DEBUG and greater) to a file with an XML
            layout.</para>

            <programlisting format="linespecific">log4j.rootLogger=DEBUG, XmlFile

log4j.appender.XmlFile=org.apache.log4j.FileAppender
log4j.appender.XmlFile.file=isis.log.xml
log4j.appender.XmlFile.layout=org.apache.log4j.xml.XMLLayout
log4j.appender.XmlFile.append=false</programlisting>
          </sect3>

          <sect3>
            <title>Writing HTML log files</title>

            <para>HTML files can be viewed in a web browser and will display
            nicely in most email clients. Change the appender to use the
            <classname>HTMLLayout</classname> class.</para>

            <programlisting format="linespecific">log4j.appender.Snapshot.layout=org.apache.log4j.HTMLLayout</programlisting>
          </sect3>
        </sect2>

        <sect2>
          <title>Using logging to get help</title>

          <para>When you are working with someone else it is often useful to
          send details of what is happening including screenshots, code, and
          logs. To make the other person's life easier provide as much
          information as possible:</para>

          <itemizedlist>
            <listitem>
              <para>Detail the version of the framework and the platform (Java
              or .Net) you are using</para>
            </listitem>

            <listitem>
              <para>Describe the problem in detail</para>
            </listitem>

            <listitem>
              <para>Provide screenshots (as a <filename class="directory"
              moreinfo="none">.gif</filename> or <filename class="directory"
              moreinfo="none">.png</filename>, avoid jpegs and Word documents)
              that shows the problem</para>
            </listitem>

            <listitem>
              <para>Provide log files from both the client and the server in
              an XML format so they can be viewed using Chainsaw</para>
            </listitem>

            <listitem>
              <para>Include your contact details, preferrably you email
              address</para>
            </listitem>
          </itemizedlist>

          <para>Collate all this information ensuring each file is clearly
          named. Then zip up (or tar) the whole set (as the logs, in
          particular, can be huge) and email the compressed file.</para>
        </sect2>

        <sect2>
          <title>Adding logging to your code</title>

          <para>It is recommended that you also add logging to your code,
          particularly if you are developing a component or extending the
          framework in some way. This way you will be able to see the
          interaction of your classes with those of the NOF. The following
          lays out how the framework uses Log4j, and hence how you should use
          it to be consistent.</para>

          <para>Simple ensure that any class that does any logging makes a
          <classname>Logger</classname> available. By convention the name is
          always <varname>LOG</varname>. The name of the logger should be the
          name of the class in its fully qualified form. To make this easy use
          the constructor that takes a <classname>Class</classname> object and
          pass in your class using as shown here. Don't forget to add an
          import to <classname>org.apache.log4j.Logger</classname>, not the
          class of the same name in the NOF or in Java itself.</para>

          <programlisting format="linespecific">private final static Logger LOG = Logger.getLogger(IsisClass.class);</programlisting>

          <para>Where you wish to add log message add a statement like the
          following, deciding first what level the event should be classified
          as (see above); the available methods are
          <methodname>debug</methodname>, <methodname>info</methodname>,
          <methodname>warn</methodname>, <methodname>error</methodname> and
          <methodname>fatal</methodname>.</para>

          <programlisting format="linespecific">LOG.debug("mark as dirty " + object);

LOG.error("failed to create instance of " + this, e);</programlisting>

          <para>The first statement in this example contains just a message,
          while the second version logs a message and, separately, the
          complete stack trace.</para>

          <sect3>
            <title>Making you classes useful in logs</title>

            <para>To make the most of logging, even if you don't log anything
            in you code, make sure that you declare a
            <methodname>toString</methodname> method in each of you classes.
            This way when a log message is created that references your object
            the message will show your object in detail rather than like
            this:</para>

            <screen format="linespecific">MyObject@33D4</screen>

            <para>A suitable toString can cause it to be rendered more
            usefully such as:</para>

            <screen format="linespecific">MyObject [name=windows,size=34x20]</screen>

            <para></para>

            <para></para>

            <para></para>

            <para></para>
          </sect3>
        </sect2>
      </sect1>

      <sect1>
        <title>Property naming conventions</title>

        <para>Properties used within the framework start with 'isis', which is
        available from the <literal
        moreinfo="none">Configuration.ROOT</literal> constant. Next is the
        category and optionally a component. Finally is the property name
        (which can be as many levels as needed) for the component. Examples
        are:</para>

        <programlisting format="linespecific">isis.viewer.cli.log
isis.services.prefix
isis.viewer.dnd.specification.view
isis.exploration.users
isis.viewer.html.header</programlisting>
      </sect1>
    </chapter>

    <chapter id="chp.DeployingIsisApplications">
      <title>Deployment Principles</title>

      <abstract>
        <para>*** The principles for deploying an <emphasis>Isis</emphasis>
        application.</para>
      </abstract>

      <para>Assuming that you have developed your domain model and tested it
      as a standalone prototype, this part of the guide describes the basic
      deployment options.</para>

      <para>Alternative implementations (most notably, remoting for
      client/server) that allow for different deployments have their own
      guidance on deployment. The same is also true for viewers that allow for
      different deployments (eg a viewer that supports a mobile phone or
      Eclipse OSGi would likely have its own packaging requirements).</para>

      <para></para>

      <para></para>

      <para></para>

      <note>
        <para>TODO: tidy up the following paras, were just copied/pasted in
        from APT</para>
      </note>

      <para></para>

      <para>All the following describe setting up the default security
      implementations. *** Mention that there are other implementations</para>

      <para></para>

      <para></para>

      <para>For desktop-based viewers the framework provides a
      <classname>ViewerInstaller</classname> <acronym>API</acronym>, defined
      in the <filename>core/runtime</filename> module. This approach is used
      by the <acronym>DnD</acronym> viewer and the <acronym>HTML</acronym>
      viewer, for example.</para>

      <para>Alternatively the viewer can use its own mechanism to get started
      (eg as a webapp) and then simply bootstrap the Isis runtime with a
      couple of lines of code. This is the technique used by the Scimpi webapp
      viewer, by the Wicket viewer and by the Restful viewer.</para>

      <para></para>

      <para>*** x-ref remoting docs as a way of deploying in client/server
      mode.</para>

      <para></para>

      <para></para>

      <sect1>
        <title>Adding Security (Authentication and Authorization)</title>

        <para></para>

        <para>x-ref alternatives/security/file</para>

        <para></para>
      </sect1>

      <sect1>
        <title>Adding support for internationalisation</title>

        <para>All the text that appears to the user comes from the domain
        object model. Any literal text used within the code may be
        externalised, and localised using the standard Java mechanism of
        resource bundles. However as all field and menu names are derived from
        the method names the framework provides a mechanism to adapt these
        names using resource bundles as well.</para>

        <sect2>
          <title>Localisation files</title>

          <para>Create a file for each required language, e.g., <filename
          class="directory" moreinfo="none">i18n_en_GB.properties</filename>
          for English in Great Britain, and place them into the project such
          that they will be included in the class path. For the project
          structures we have already seen the files could be added to the
          <filename class="directory" moreinfo="none">resources</filename>
          directory, as the following example shows.</para>

          <screen format="linespecific">resources/
   <emphasis role="strong">i18n_en_GB.properties
   i18n_de_DE.properties
   i18n_fr_FR.properties</emphasis>
   </screen>

          <para>The following example is part of one of those translation file
          and shows how property and action names and descriptions may be
          specified.</para>

          <programlisting format="linespecific">example.dom.Contact.property.Phone.name=Tlphone
example.dom.Contact.action.NewPhone.name=Nouveau tlphone
example.dom.Contact.property.FullName.description=Le nom complet du client</programlisting>

          <para>For more details on defining localisation files, <xref
          linkend="i18n-files" />.</para>
        </sect2>

        <sect2>
          <title>Configuration</title>

          <para>The reflector needs to be decorated with a facet decorator to
          look up the translated names every time the framework needs
          information about the fields and menus. To include the decorator add
          the following to a properties file.</para>

          <programlisting format="linespecific">isis.reflector.facet-decorators=resource-i18n</programlisting>

          <para>If the application is being accessed via the web (html)
          viewer, then the server will need to perform the localisation, so
          the above property should be included in one of isis.properties read
          by the server; if the application is being accessed by a client
          (e.g. the DND viewer) then the localisation will be performed within
          the client, and the property should be specified in one of the
          properties files read by the client e.g. <filename class="directory"
          moreinfo="none">facet-decorator_i18n.properties</filename>.</para>

          <para>The locale will be picked up automatically from the machine on
          which the code is executing. You may override this by specifying the
          <link linkend="locale">locale</link> in a properties file.</para>
        </sect2>
      </sect1>
    </chapter>
  </part>
</book>
