= Simple App Archetype
:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
include::_attributes.adoc[]

The quickest way to get started building an application "for real" is to run the `simpleapp` archetype.
Like the xref:helloworld:ROOT:about.adoc[helloworld archetype], this too will generate a very simple one-class domain model (an entity called `SimpleObject` with a couple of properties).

However, the generated application also provides more structure to assist you as your application grows.

We'll talk more about the structure of the generated app xref:about.adoc#structure-of-the-app.adoc[below], but for now let's see how to generate the application.


[TIP]
====
The (non-ASF) Incode Platform's link:http://platform.incode.org/quickstart/quickstart.html[quickstart archetype] builds upon the simpleapp archetype, but also adds in support for various Incode Platform modules such as security, auditing, commands and publishing.
====


== Prerequisites

Apache Isis is a Java based framework, so in terms of prerequisites, you'll need to install:

* Java 8 JDK
* link:http://maven.apache.org[Apache Maven] 3.5+

You'll probably also want to use an IDE; the Apache Isis committers use either IntelliJ or Eclipse; in the xref:support:dg:ide.adoc[Developers' Guide] we have detailed setup instructions for using these two IDEs.
If you're a NetBeans user you should have no problems as it too has strong support for Maven.

When building and running within an IDE, you'll also need to configure the Datanucleus enhancer.
This is implemented as a Maven plugin, so in the case of IntelliJ, it's easy enough to run the enhancer as required.
It should be just as straightforward for NetBeans too.

For Eclipse the maven integration story is a little less refined.
All is not lost, however; DataNucleus also has an implementation of the enhancer as an Eclipse plugin, which usually works well enough.




== Generating the App

Create a new directory, and `cd` into that directory.

To build the app from the latest stable release, then run the following command:

[source,bash,subs="attributes+"]
----
mvn archetype:generate  \
    -D archetypeGroupId=org.apache.isis.archetype \
    -D archetypeArtifactId=simpleapp-archetype \
    -D archetypeVersion={isiscurr} \
    -D groupId=com.mycompany \
    -D artifactId=myapp \
    -D version=1.0-SNAPSHOT \
    -B
----

where:

- `groupId` represents your own organization, and
- `artifactId` is a unique identifier for this app within your organization.
- `version` is the initial (snapshot) version of your app

The archetype generation process will then run; it only takes a few seconds.




== Structure of the App

As mentioned above, the application generated by the simpleapp archetype is a multi-module project, structured so that you easily extend it as your application grows.

The application consists of three modules, with a top-level module acting as an aggregator and also parent:

image::using-simple-app/structure/structure/Slide1.PNG[width="800px",link="{imagesdir}/using-simple-app/structure/structure/Slide1.PNG"]

The application separates domain object model holding the business logic (the `myapp-module-simple` Maven module containing `SimpleObject` entity and supporting domain classes) from the bootstrapping modules (`myapp-application` Maven module and the `myapp-webapp` module).

In a larger application there would likely be many more modules containing these domain object modules.
For example, you might have a `myapp-module-customer` holding a `Customer` entity and related entities/services, a `myapp-module-product` holding a `Product` catalog, and a `myapp-module-order` to hold the ``Order``s placed by ``Customer``s:

image::using-simple-app/structure/structure/Slide2.PNG[width="800px",link="{imagesdir}/using-simple-app/structure/structure/Slide2.PNG"]

We can use Maven dependency management to ensure that there are no cyclic dependencies (order "knows about" product but product does not know about orders) and ensure that the codebase remains decoupled.
When Java9 modules are commonplace, we'll also be able to restrict visibility of classes between modules.

[WARNING]
====
Note that while Maven dependencies are transitive (in the example the `myapp-application` needs only depend directly on `myapp-module-order`, the modules defined in the `AppManifest` are _not_ transitive: all modules must be listed.
====

Let's now review the contents of each of the generated modules.


=== myapp (parent)

The parent module is a fairly conventional, declaring its child modules (using `<dependencyManagement>` elements) and aggregating them (using `<module>` elements).

[NOTE]
====
One thing you'll discover when you review the generated classes is that they all reside under the `domainapp` package.

While it's more conventional to use the inverse domain name for package (eg `com.mycompany.myapp`, that's only really appropriate for library code that will be released for reuse by multiple applications in different orgnisations (eg open source).

For internal application though this is less of a concern; indeed, avoiding the domain name means that if the company rebrands or is taken over then nothing needs be changed.

Of course, you are always free to move the classes to a different package if you wish.
====



=== myapp-application

The production classes for `myapp-application` module (in `src/main/java`) are:

[source]
----
src/
  main/
    java/
      domainapp/
        application/
          DomainAppApplicationModule.java
          fixture/
            DomainAppFixtureScriptsSpecificationProvider.java
            scenarios/
              DomainAppDemo.java
          manifest/
            DomainAppAppManifest.java
            DomainAppAppManifestBypassSecurity.java
            DomainAppAppManifestWithFixtures.java
            DomainAppAppManifestWithFixturesBypassSecurity.java
            isis-non-changing.properties
            menubars.layout.xml
          services
            healthcheck
              HealthCheckServiceImpl.java
            homepage
              HomePageService.java
              HomePageViewModel.java
              HomePageViewModel.layout.xml
              HomePageViewModel.layout.png
----

==== Manifest

The `DomainAppAppManifest` is the most important class here, typically being used to bootstrap the application.
It is quite short:

[source,java]
----
public class DomainAppAppManifest extends AppManifestAbstract2 {

    public static final Builder BUILDER = Builder
            .forModule(new DomainAppApplicationModule())
            .withConfigurationPropertiesFile(
                    DomainAppAppManifest.class, "isis-non-changing.properties")
            .withAuthMechanism("shiro");

    public DomainAppAppManifest() {
        super(BUILDER);
    }
}
----

Rather than implement `AppManifest` directly, `DomainAppAppManifest` uses the builder provided by the convenience `AppManifestAbstract2`), to define three things:

* a list of modules - there's just one, `DomainAppApplicationModule`
* the location of a configuration file, `isis-non-changing.properties`, read in as a resource from the classpath
* specifying an authentication/authorisation mechanism, in this case Apache Shiro integration.

The manifest uses the builder defined by `AppManifestAbstract2` and references a single top-level (Isis) module, namely `DomainAppApplicationModule`:

[source,java]
----
public class DomainAppApplicationModule extends ModuleAbstract {
    @Override
    public Set<Module> getDependencies() {
        return Sets.<Module>newHashSet(new SimpleModule());
    }
}
----

where `SimpleModule` in defined in the `mypp-module-simple` module (below).

The primary purpose of the module class is to identify packages and subpackages that the framework should scan for entities and domain services.
The transitive dependencies between modules are automatically resolved.
The net effect is that all the domain services and entities in this module as well as those modules referenced are included into the app.

Going back to the manifest, it also defines the `isis-non-changing.properties` configuration properties, loaded as a static resource from the classpath.

You'll find that there's also a similar file called `isis.properties`, which resides at `WEB-INF/isis.properties`.
This also provides configuration options (the framework simply combines them) but those in `WEB-INF/isis.properties` are restricted to settings that are likely to change from environment to environment, most notably JDBC URL connection strings.
Separating these out makes it easy to reconfigure the application to run against different databases in different environments (dev, test, production etc).

Finally, the app manifest identifies Apache Shiro for authentication and authorisation.
Shiro in turn is configured using the `WEB-INF/shiro.ini` file.

[TIP]
====
The security integration provided by Apache Isis and Shiro is quite sophisticated; to get started though you can just login using username: `sven`, password: `pass`.
====

The `menubars.layout.xml` file also resides in the same package as the manifest; this defines the menubar structure.

There are also several variations on the app manifest; these can be used to bootstrap the application with fixtures, or disabling security.

==== Domain Services

The `domainapp.application.services` package contains two SPI implementations.

The `HomePageService` domain service simply has a single action annotated with `@HomePage`:

[source,java]
----
@Action(semantics = SemanticsOf.SAFE)
@HomePage
public HomePageViewModel homePage() {
    return factoryService.instantiate(HomePageViewModel.class);
}
----

which returns the `HomePageViewModel` for use as the home page.
The `HomePageViewModel` itself just renders a collection of ``SimpleObject``s in a list (`HomePageViewModel.layout.xml` defines the UI layout).

The other SPI implementation is the `HealthCheckServiceImpl` domain service, which is used to indicate if the application is running healthily.
This is exposed as the `/restful/health` REST endpoint.
The implementation itself simply runs a query on the `SimpleObjects` repository service, thus checking that the database is configured correctly and available.


==== Fixtures

The final package in the application module is `domainapp.application.fixture`.
The important class here is `DomainAppDemo`, a fixture script that can be used to setup the application with some dummy data.
This is used in the app itself when running in prototype mode (against an in-memory database), and can also be used by integration tests.

There is in fact also a domain service defined here, namely `DomainAppFixtureScriptsSpecificationProvider`.
This is just used to configure the run fixture script menu item shown on the "Prototyping" menu.

The module also defines a number of BDD specs and integration tests, in `src/test/java`.
The BDD specs (run using Cucumber) reside under `domain.application.bdd`:

[source]
----
src/
  test/
    java/
      domainapp/
        application/
          bdd/
            specglue/
              BootstrappingGlue.java
              CatalogOfFixturesGlue.java
            specs/
              RunIntegBddSpecs.java
              SimpleObjectSpec_listAllAndCreate.feature
----

Here the `BootstrappingGlue` glue class inherits from the framework's `HeadlessWithBootstrappingAbstract` class, and bootstraps using the `DomainAppApplicationModule` mentioned above.

There is just one feature file: `SimpleObjectSpec_listAllAndCreate.feature`, which is pretty simple:

[source,feature]
----
@DomainAppDemo
Feature: List and Create New Simple Objects

  Scenario: Existing simple objects can be listed and new ones created
    Given there are initially 10 simple objects
    When  I create a new simple object
    Then  there are 11 simple objects
----


The `@DomainAppDemo` annotation causes the `DomainAppDemo` fixture script to be run; this is the purpose of the `CatalogOfFixturesGlue` glue class.

The specs themselves are run by the `RunIntegBddSpecs.java` class, which specifies which packages to search for "glue".
This is just standard Cucumber bootstrapping.

The integration tests meanwhile are in `domainapp.application.integtests`:

[source]
----
src/
  test/
    java/
      domainapp/
        application/
          integtests/
            DomainAppIntegTestAbstract.java
            mml/
              approved/
              received/
              MetaModelService_IntegTest.java
            smoke/
              Smoke_IntegTest.java
----

There are two different sets of tests.

* The `Smoke_IntegTest` performs a number of high-level smoke tests, to check that the core functionality works correctly.
+
This test inherits `DomainAppIntegTestAbstract`, which in turn inherits from `IntegrationTestAbstract3` and uses the `DomainAppApplicationModule` previously discussed.
+
Moreover, the `Smoke_IntegTest` uses the same `DomainAppDemo` fixture script.
The application and the smoke tests therefore run with the exact same state, making debugging easy.

* The `MetaModelService_IntegTest` demonstrates how to use approval tests to verify that the metamodel is unchanged between releases of Apache Isis.
+
By default this test does nothing; it is activated by setting system properties ("lockdown.learn" or "lockdown.verify").
When in "learn" mode, the test calls the `MetaModelService` to export an XML representation of the internal metamodel.
These can then be moved from the `received` directory to the `approved` directory, as "known-to-good".
+
Then, if Apache Isis is updated, then the "verify" test can be called to check that the metamodel created by the new version of the framework is the same as the previous version.

With regard to the naming of these various BDD specs and integration tests, they follow the naming convention required by the (non-ASF) link:http://github.com/danhaywood/java-mavenmixin-surefire["surefire" mavenmixin] that configures the maven surefire plugin.



=== myapp-module-simple

This module is where the domain object model lives, that is the business logic of the application itself.
This typically comprises entities, domain services, mixins and view models.


[TIP]
====
As discussed above, larger applications will likely have multiple modules each containing their own slice of business logic.

Initially though you should probably just use regular Java packages to separate out functionality; you can carve out separate modules later on once the responsibilities of each have settled down.
====


The classes for the simple module reside in the `domainapp.modules.simple` package.
Under `src/main/java` we have:


//│
//&boxv;
//┌
//&boxdr;
//┐
//&boxdl;
//└
//&boxur;
//┘
//&boxul;
//├
//&boxvr;
//┤
//&boxvl;
//┬
//&boxhd;
//┴
//&boxhu;
//┼
//&boxvh;

[source]
----
src/
  main/
    java/
      domainapp/
        application/
          DomainAppApplicationModule.java
          fixture/
            DomainAppFixtureScriptsSpecificationProvider.java
            scenarios/
              DomainAppDemo.java
          manifest/
            DomainAppAppManifest.java
            DomainAppAppManifestBypassSecurity.java
            DomainAppAppManifestWithFixtures.java
            DomainAppAppManifestWithFixturesBypassSecurity.java
            isis-non-changing.properties
            menubars.layout.xml
          services
            healthcheck
              HealthCheckServiceImpl.java
            homepage
              HomePageService.java
              HomePageViewModel.java
              HomePageViewModel.layout.xml
              HomePageViewModel.layout.png
----

The `SimpleModule` is the (single) module class referenced from the previously discussed `DomainAppApplicationModule`, meaning that all the entities, domain services and fixtures within it are included within the application.

* `SimpleObject` is the (one-and-only) domain entity defined (with `SimpleObject.layout.xml` defines its layout in the UI).

* `SimpleObjects` domain service's whos actions appear as menu items and which acts as a repository to create and find ``SimpleObject``s.

The `SimpleModule` class also defines a teardown fixture, automatically called by integration tests.

[source,java]
----
public class SimpleModule extends ModuleAbstract {
    @Override
    public FixtureScript getTeardownFixture() {
        return new TeardownFixtureAbstract2() {
            @Override
            protected void execute(ExecutionContext ec) {
                deleteFrom(SimpleObject.class);
            }
        };
    }
    ...
}
----

In the `fixture` subpackage is the `SimpleObject_persona` "persona" which uses the corresponding `SimpleObjectBuilder` builder script; further discussion on this pattern xref:ug:tst:fixture-scripts/api-and-usage#persona-and-builders.adoc[here].
These fixtures are also used by "local" integration tests, which reside under `src/test/java`.

There are also unit tests and "glue" for the BDD specs:

[source]
----
src/
  test/
    java/
      domainapp/
        modules/
          simple/
            dom/
              impl/
                SimpleObject_Test.java
                SimpleObjectRepository_Test.java
            integtests/
              SimpleModuleIntegTestAbstract.java
                tests/
                  SimpleObject_IntegTest.java
                  SimpleObjectMenu_IntegTest.java
              specglue/
                SimpleObjectMenuGlue.java
----

The simpleapp application has both "local" integration tests (defined within the `myapp-module-simple` module) and also "global" integration tests (the "smoke" tests in `myapp-application` module).
There's a role for both: local integration tests should fully exercise the module but may need to mock out collaborations between modules, while global integration tests exercise the whole application (but an over-reliance on these can cause test run times to bloat).

With regard to the naming of these various BDD specs and integration tests, they follow the naming convention required by the (non-ASF) link:http://github.com/danhaywood/java-mavenmixin-surefire["surefire" mavenmixin] that configures the maven surefire plugin.
Integration tests include the name "IntegTest", while unit tests contain merely "Test".

The module also defines its own manifest, `SimpleModuleManifest`.
This is used to run Isis' own xref:rg:mvn:about.adoc[maven plugin] to xref:rg:mvn:validate.adoc[validate] the domain object model (eg to detect orphaned supported methods).



=== myapp-webapp

Finally, in the `myapp-webapp` module we have the configuration to package and bootstrap the application as a webapp.
Under `src/main/webapp` are various resources, used either to configure the webapp, or that are served up by the running webapp:

[source]
----
src/
  main/
    webapp/
      src/
        main/
          webapp/
            about/
              index.html
            css/
              application.css
            scripts/
              application.js
            swagger-ui/
            WEB-INF/
              isis.properties
              logging.properties
              shiro.ini
              translations.po
              web.xml
----

Most important of these is `WEB-INF/web.xml`, which bootstraps both the Wicket viewer and the Restful Objects viewer, along with Shiro security.
This is done using a webapp context listener:

[source,xml]
.web.xml
----
<web-app ...>
  ...
  <listener>
      <listener-class>org.apache.isis.core.webapp.IsisWebAppContextListener</listener-class>
  </listener>
  ...
</web-app>
----

The `about/index.html` is the page shown at the root of the package, providing links to either the Wicket viewer or to the Swagger UI.
In a production application this is usually replaced with a page that does an HTTP 302 redirect to the Wicket viewer.

In `css/application.css` you can use to customise CSS, typically to highlight certain fields or states.
The pages generated by the Wicket viewer have plenty of CSS classes to target.
You can also implement the `cssClass()` method in each domain object to provide additional CSS classes to target.

Similarly, in `scripts/application.js` you have the option to add arbitrary Javascript.
JQuery is available by default.

In `swagger-ui` is a copy of the Swagger 2.x UI classes, preconfigured to run against the REST API exposed by the Restful Objects viewer.
This can be useful for developing custom applications, and is accessible from the initial page (served up by `about/index.html`).

Finally in `WEB-INF` we have the standard `web.xml` (already briefly discussed) along with several other files:

* `isis.properties` contains further configuration settings for Apache Isis itself.
+
(As already discussed), these are in addition to the configuration properties found in various configuration properties that live alongside and that are loaded by the `DomainAppAppManifest` class.
Those in the WEB-INF/isis.properties file are those that are likely to change when running the application in different environments.

* `logging.properties` configures log4j.
+
The framework is configured to use slf4j running against log4j.

* `shiro.ini` configures Apache Shiro, used for security (authentication and authorisation)

* `web.xml` configures the Wicket viewer and Restful Objects viewer.
It also sets up various filters for serving up static resources with caching HTTP headers.

The webapp module's `pom.xml` also has several tricks up its sleeve:

* most fundamentally, it allows the application to be packaged up as a regular `.war` file for deployment to a servlet container such as Tomcat 8.x

* it also uses the jetty-console mavenmixin to package the application as a standalone executable JAR (with an embedded jetty container).
+
The files in `src/main/jettyconsole` provide a splash image (if not run in headless mode).

* the docker mavenmixin packages up the application as a docker image.
+
This uses the Dockerfile residing in `docker/Dockerfile` (under `src/main/resources`).

* also, the xref:rg:mvn:about.adoc[Apache Isis Maven plugin] is also configured to generate a xref:rg:mvn:swagger.adoc[swagger] spec file for the entire application, in the `xxx-webapp` module

Under `src/main/resources` there is:

[source]
----
src/
  main/
    resources/
      docker/
        Dockerfile
----

As you might expect, this is used to create a Docker image.
The `Dockerfile` is very simple; the built webapp is deployed as the ROOT.war into Apache Tomcat:

[source,Dockerfile]
.Dockerfile
----
FROM incodehq/tomcat
RUN rm -rf ${DEPLOYMENT_DIR}/ROOT
COPY ${docker-plugin.resource.include} ${DEPLOYMENT_DIR}/ROOT.war
EXPOSE 8080
----


Now you know your way around the code generated by the archetype, lets see how to build the app and run it.



== Building the App

Switch into the root directory of your newly generated app, and build your app:

[source,bash]
----
cd myapp
mvn clean install
----

where `myapp` is the `artifactId` entered above.



== Running the App

The `simpleapp` archetype generates a single WAR file, configured to run both the xref:ug:vw:about.adoc[Wicket viewer] and the xref:ug-vro:ROOT:about.adoc[Restful Objects viewer].
The archetype also configures the DataNucleus/JDO Objectstore to use an in-memory HSQLDB connection.

Once you've built the app, you can run the WAR in a variety of ways.


=== Using mvn Jetty plugin

First, you could run the WAR in a Maven-hosted Jetty instance, though you need to `cd` into the `webapp` module:

[source,bash]
----
mvn -pl webapp jetty:run
----


You can also provide a system property to change the port:

[source,bash]
----
mvn -pl webapp jetty:run -D jetty.port=9090
----


=== Using a regular servlet container

You can also take the built WAR file and deploy it into a standalone servlet container such as [Tomcat](http://tomcat.apache.org).
The default configuration does not require any configuration of the servlet container; just drop the WAR file into the `webapps` directory.



=== Using Docker

It's also possible to package up the application as a docker image to run as a container.

* To package up the application as a docker image (specifying the docker image name as a system property): +
+
[source,bash]
----
mvn install -Dmavenmixin-docker -Ddocker-plugin.imageName=mycompany/myapp
----
+
Alternatively, define the `${docker-plugin.imageName}` in the `webapp` module and use simply: +
+
[source,bash]
----
mvn install -Dmavenmixin-docker
----
+
The packaged image can be viewed using `docker images`.

* To run a docker image previously packaged: +
+
[source,bash]
----
docker container run -d -p 8080:8080 mycompany/myapp
----
+
This can then be accessed at link:http://localhost:8080[localhost:8080].
+
See link:https://github.com/danhaywood/java-mavenmixin-docker#how-to-consume[mavenmixin-docker] for further details on how to run docker images.

* To upload the application as a docker image to link:https://hub.docker.com[docker hub] (or some other docker registry): +
+
[source,bash]
----
mvn -pl webapp deploy -Dmavenmixin-docker
----
+
This assumes that the `${docker-plugin.imageName}` property has been defined, _and_ also that docker registry credentials have been specified in `~/.m2/settings.xml`.
Once more, see link:https://github.com/danhaywood/java-mavenmixin-docker#how-to-configure[mavenmixin-docker] for further details.



=== From within the IDE

Most of the time, though, you'll probably want to run the app from within your IDE.
The mechanics of doing this will vary by IDE; see the xref:support:dg:ide.adoc[Developers' Guide] for details of setting up Eclipse or IntelliJ IDEA.
Basically, though, it amounts to running `org.apache.isis.WebServer`, and ensuring that the xref:support:dg:hints-and-tips/datanucleus-enhancer.adoc[DataNucleus enhancer] has properly processed all domain entities.

Here's what the setup looks like in IntelliJ IDEA:

image::simpleapp-webapp.png[width="600px",link="{imagesdir}/simpleapp-webapp.png"]

with the maven goal to run the DataNucleus enhancer (discussed in more detail xref:support:dg:hints-and-tips/datanucleus-enhancer.adoc[here]) before launch defined as:

image::simpleapp-webapp-before-launch.png[width="600px",link="{imagesdir}/simpleapp-webapp-before-launch.png"]



== Running with Fixtures

It is also possible to start the application with a pre-defined set of data; useful for demos or manual exploratory testing.
This is done by specifying a xref:ug:tst:fixture-scripts.adoc[fixture script] on the command line.

If you are running the app from an IDE, then you can specify the fixture script using the `--fixture` flag.  The archetype provides the `domainapp.fixture.scenarios.RecreateSimpleObjects` fixture script, for example:

image::simpleapp-webapp-with-fixtures.png[width="600px",link="{imagesdir}/simpleapp-webapp-with-fixtures.png"]

Alternatively, you can run with a different xref:rg:cms:classes/AppManifest-bootstrapping.adoc[`AppManifest`] using the `--appManifest` (or `-m`) flag.
The archetype provides
`domainapp.app.DomainAppAppManifestWithFixtures` which specifies the aforementioned `RecreateSimpleObjects` fixture.



== Using the App

The generated application is almost identical similar to that generated by xref:helloworld:ROOT:about.adoc[helloworld archetype]; a description of how to use it can be found xref:helloworld:ROOT:about.adoc#using-the-app[here].

One additional feature that the simpleapp contains over the helloworld app is a home page.
This shows all domain objects (as installed by fixture scripts, described xref:simpleapp:ROOT:about.adoc#running-with-fixtures[above]).

image::using-simple-app/030-home-page.png[width="600px",link="{imagesdir}/using-simple-app/030-home-page.png"]

It's also possible to run fixture scripts from the app itself:

image::using-simple-app/040-run-fixture-script-menu.png[width="600px",link="{imagesdir}/using-simple-app/040-run-fixture-script-menu.png"]

Some fixture scripts may allow their default behaviour to be tweaked ((eg specify how many objects to create):

image::using-simple-app/050-run-fixture-script-prompt.png[width="600px",link="{imagesdir}/using-simple-app/050-run-fixture-script-prompt.png"]

The table summarises the resultant fixtures that were run:

image::using-simple-app/060-run-fixture-script-result.png[width="600px",link="{imagesdir}/using-simple-app/060-run-fixture-script-result.png"]

Navigating back to the home page shows the newly created objects:

image::using-simple-app/070-home-page.png[width="600px",link="{imagesdir}/using-simple-app/070-home-page.png"]



== Using GitLab CI and DockerHub

The archetype provides configuration files to allow you to build and package the application using link:https://gitlab.com/[GitLab] (for continuous integration pipelines) and link:https://hub.docker.com/[Docker Hub] (as a registry of Docker images).

To use, you'll need an account on both GitLab and DockerHub.

=== DockerHub

Simply create Docker repository "myapp" in DockerHub.


=== Source code

In the `.gitlab-ci.yml` file, update the name of the Docker repository on DockerHub:

[source,yml]
----
variables:
  ...
  DOCKER_REGISTRY_REPOSITORY: "myapp"
----

=== GitLab

Create a git repository "myapp" in GitLab.

Using Settings > CI/CD, specify the following _Secret Variables_:

* `DOCKER_REGISTRY_USERNAME` - corresponds to user account name on DockerHub
* `DOCKER_REGISTRY_PASSWORD` - corresponding password
* `DOCKER_REGISTRY_EMAIL` - associated email for the user account

Finally, push a copy of the generated application to this repository using the instructions provided by GitLab.

This will kick off a pipeline that will build the image and push to DockerHub.

image::dockerhub-tags.png[width="600px",link="{imagesdir}/dockerhub-tags.png"]

The tag name is based on a combination of the date, the branch and the git shaId.


=== Running the Image

You can run the image in a new container using:

[source,bash]
----
docker run -p 8080:8080 -d XXX/YYY:ZZZ
----

where

* `XXX` is your DockerHub account name (`DOCKER_REGISTRY_USERNAME` secret variable in GitLab CI)
* `YYY` is the name of the DockerHub registry (`DOCKER_REGISTRY_REPOSITORY` in the `.gitlab-ci.yml` file)
* `ZZZ` is the tag of the image to run


For example, using the screenshot above, that image could be run using:

[source,bash]
----
docker run -p 8080:8080 -d danhaywood/simpleapp:20180315.0935.master.4521215
----


== Modifying the App

Once you are familiar with the generated app, you'll want to start modifying it.
There is plenty of guidance on this site; start with this guide (fundamentals) and then look at the other guides linked to from the top-level menu or from the main xref:toc:ROOT:about.adoc[table of contents].

If you use IntelliJ IDEA or Eclipse, do also install the xref:support:dg:ide/intellij.adoc#live-templates[live templates (for IntelliJ)] / xref:support:dg:ide/eclipse.adoc#editor-templates[editor templates (for Eclipse)]; these will help you follow the Apache Isis naming conventions.

