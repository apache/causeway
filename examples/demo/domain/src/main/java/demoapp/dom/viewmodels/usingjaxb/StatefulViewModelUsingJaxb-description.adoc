End users interact with link:https://isis.apache.org/userguide/${ISIS_VERSION}/fun/overview.html#view-models[view models] in the same as a domain entity.

However, whereas domain entities are mapped to a datastore, view models are not.
Instead they are recreated dynamically by serializing their state, typically into the URL itself.

The framework provides a number of ways to serialize this state, but the most flexible and standard is to use JAXB annotations:

[source,java]
----
@XmlRootElement(name = "demo.DemoStatefulViewModel")     // <.>
@XmlType                                                    // <.>
@XmlAccessorType(XmlAccessType.FIELD)                       // <.>
@DomainObject(
        nature=Nature.VIEW_MODEL
        , objectType = "demo.DemoStatefulViewModel"
)
public class StatefulViewModelUsingJaxb implements HasAsciiDocDescription {

    // ...

    @Property(editing = Editing.ENABLED)
    @Getter @Setter
    private String message;                                 // <.>
}
----

<.> mandatory, specifies this is a JAXB element
<.> mandatory boilerplate
<.> serializes the state by reading the field
<.> no further JAXB annotations required for the property.

Notice how the 'message' property can be modified and survives a refresh of the page.

Behind the scenes, the object is converted into an XML serialization, and that is URL encoded.


== Collections

JAXB also handles serializing graphs of data, which means that view models can also have collections of other objects:

[source,java,indent=0]
----
    @XmlRootElement(name = "child")
    @XmlType
    @XmlAccessorType(XmlAccessType.FIELD)
    @Data
    public static class Child {
        @Title
        private String name;
    }

    @Getter @Setter
    @Collection
    @XmlElementWrapper(name = "children")
    @XmlElement(name = "child")
    private List<Child> children = new ArrayList<>();
----

The demo provides a couple of actions to allow objects to be added and removed.

[source,java,indent=0]
----
    @Action(associateWith = "children", associateWithSequence = "1", semantics = SemanticsOf.NON_IDEMPOTENT)
    public StatefulViewModelUsingJaxb addChild(final String name) {
        val child = new Child();
        child.setName(name);
        children.add(child);
        return this;
    }

    @Action(associateWith = "children", associateWithSequence = "2", semantics = SemanticsOf.IDEMPOTENT)
    public StatefulViewModelUsingJaxb removeChild(final Child child) {
        children.remove(child);
        return this;
    }
    public List<Child> choices0RemoveChild() { return getChildren(); }
    public String disableRemoveChild() {
        return choices0RemoveChild().isEmpty()? "No children to remove" : null;
    }


----

NOTE: the child object has value-type semantics (is annotated with `@lombok.Data`).

TODO: references to persistent java entities

== Long URLs

As you can see this can result in long URLs.
If the URL is too long, or needs to be encrypted, then the link:https://isis.apache.org/refguide/${ISIS_VERSION}/applib-svc/UrlEncodingService.html[`UrlEncodingService`] SPI can provide for different serializations.

