<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.1//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.1/sdocbook.dtd">
<article>
  <articleinfo>
    <title></title>

    <author>
      <firstname></firstname>

      <surname></surname>

      <affiliation>
        <orgname></orgname>
      </affiliation>
    </author>

    <pubdate></pubdate>
  </articleinfo>

  <section>
    <title>Reflection</title>

    <para>To make the domain objects useful within the framework the objects'
    public interfaces must be exposed. Reflection capabilities are used to
    determine what fields or properties an object has, what behaviour it can
    offer, and to find other information such as the object's title, a
    suggested order of it fields, when the actions can or can't be used. The
    details about this interface are recorded in an instance of
    <literal>ObjectSpecification</literal>. As each class of domain
    object is loaded into the system introspection is performed and an
    instance of <literal>ObjectSpecification</literal> is generated. That
    specification object is subsequently available from any object adapter
    (using the <literal>ObjectAdapter.getSpecification</literal> method) for
    that type of domain object; or it can be retrieved directly, by name or
    class, from the <literal>ObjectSpecificationLoader</literal> instance
    (obtained from the <literal>Isis</literal> repository).</para>

    <para>Through an object's <literal>ObjectSpecification</literal>
    instance the rest of the NOF can find out the fields that an object has,
    the methods it offers, the title to use to identify the object, and other
    details about the object. These are used normally used by the
    implementations of ObjectAdapter etc when another component ask the adapter
    for details about another object. For example For example the statement
    <literal>adapter.getField(no.getFields()[0])</literal> would retrieve the
    first field in the domain object held by the [[NAME]] referenced by
    <literal>adapter</literal>.</para>

    <para>How it Works</para>

    <para>When a domain object is used within the NOF the
    <literal>ObjectSpecificationLoader</literal> instance is asked for
    the <literal>ObjectSpecification</literal> for the domain object's
    class (by name or <literal>java.lang.Class</literal> object). For
    performance reasons these objects are normally cached and if the class has
    previously been introspected then the cached version would be returned.
    The first time that class is requested however the loader is responsible
    for performing the introspection and creating a complete
    <literal>ObjectSpecification</literal>.</para>

    <para>For each field that the reflector recognises the loader creates
    either a <literal>OneToOneAssociation</literal> object for a value field
    or a reference field, or a <literal>OneToManyAssociation</literal> object
    for a collection or array. Using the field objects the NOF can access or
    change the values and references in the domain object. The fields can also
    be used by the NOF to find out the field name, if the fields are visible
    and whether it can be modified.</para>

    <para>For each action method that the reflector recognises the loader must
    create an <literal>Action</literal> object. Using the action object the
    NOF can invoke the method on the domain object. The action object also can
    be used by the NOF to find out the action's name, whether it is visible
    and whether it can be executed.</para>

    <para>In addition to the fields and actions the specification must can
    also: return the various forms of class name (singular; plural; short; and
    full); retrieve a title from, or generate a title for, the domain object;
    flag the type of object (abstract, lookup, object, value, and whether
    persistable); refer to its superclass, any inteferfaces it implements and
    any subclasses; and allow objects to marked/cleared as being dirty.</para>

    <para>Installation</para>

    <para>To set up the NOF to use a reflection mechanism the
    <literal>Isis</literal> repository must be given a
    <literal>ObjectSpecificationLoader</literal> instance before the
    repository is initialised. This can be done using the repository's static
    <literal>setSpecificationLoader</literal> method. For example, the
    following sets the NOF up to use the basic reflector.</para>

    <programlisting>ObjectSpecificationLoader loader = new JavaSpecificationLoader(); 
Isis.setSpecificationLoader(loader);</programlisting>

    <para></para>
  </section>

  <section>
    <title>Getting help</title>

    <section>
      <title></title>

      <para>TODO list out the forums etc</para>

      <para></para>

      <para></para>

      <para>If you are asked from diagnostic information then run [[NAME]]
      Objects as follows to capture details about your machine, configuration
      and [[NAME]].</para>

      <programlisting format="linespecific">$ isis.sh --diagnostics &gt; diagnostics.txt</programlisting>
    </section>

    <section>
      <title>Server monitoring</title>

      <para>The NO server can be monitored via a web browser using <ulink
      url="http://localhost:8081/">http://localhost:8081/</ulink>.</para>

      <para>The port can be changed from its default of 8081 using the port
      property like this:</para>

      <programlisting format="linespecific">isis.monitor.http.port=9000</programlisting>

      <para>The NO server can also be monitored using telnet on port
      8009.</para>

      <para>The port can be changed from its default of 8009 using the port
      property like this:</para>

      <programlisting format="linespecific">isis.monitor.telnet.port=9000</programlisting>

      <para>Commands include: Overview, Authenticator, Configuration,
      Reflector, Listeners, Events, Contexts, shutdown and bye.</para>

      <para>Shutdown terminate the NO server.</para>

      <para>Bye disconnects the telnet session.</para>

      <para></para>
    </section>

    <section>
      <title>Loading configurations</title>

      <para>Configurations are loaded by a ConfigurationLoader. The loader
      should immediately create a Configuration object, and then can be used
      to add more confiration properties to the configuration object, ie
      properties cannot be added the Configuration object directly. Properties
      can loaded via the ConfigurationLoader either from files, via Properties
      object, or as key-value pairs. When files are loaded they can be
      specified, via the addConfigurationFile(file name, ensure loaded)
      method, as mandatory or optional. If mandatory then the file must
      exist.</para>

      <para>Although properties can be accessed from the Configuration object
      at any point, it should be remembered that the properties that it
      contains only include properties that have been loaded so far.</para>

      <para>The default property loader (ConfigurationDefaultLoader) reads the
      file isis.properties from the directory config. The directory
      can be changed by specifying it as the parameter of the single parameter
      constructor. This loader uses Java style property files of the
      form</para>

      <programlisting format="linespecific">name=value
name2=value2 </programlisting>

      <para></para>
    </section>
  </section>

  <section>
    <title>Remoting</title>

    <para>[[NAME]] allows remote clients to interact with a server by
    passing requests over a communication for another VM to deal with instead
    of user's VM as would happen in the standalone version. Each request
    starts by passing over authentication details to ensure the user is valid
    and to allow request to be authorised (altough requests are never passed
    from the client when the client knows it is not authorised, this guards
    against malicious access). Following that is the data for the request and
    here references are passed (using the <literal>Oid</literal> class) for
    persistent object, while graphs of data are passed for transient
    objects.</para>

    <para>Requests are routed to the <literal>ServerFacade</literal> object,
    where each specific request results in a calls to a specific method. For
    example a find request goes to the <literal>findInstances</literal> method
    while a change to an objects property goes to the
    <literal>setAssociation</literal> method. The facade then decodes the
    parameters of the request into objectst that [[NAME]] can deal with.
    So, for example, an <literal>IdentityData</literal> is used to look up a
    persistent instance, while a identifier string is used to find a
    <literal>ObjectMember</literal>. With the details of the request
    converted to [[NAME]] objects the requisite call is made into the
    [[NAME]] system. After that call is made two things are returned to
    the client, this time by converting [[NAME]] objects to transferable
    data objects. First, the result of the call into [[NAME]] is return
    and, second, any changes made to any objects involved (the object changed
    set) are passed back for the client to update the objects that it
    has.</para>

    <para>Connections from the client are accepted by the ServerListener,
    which in the case the</para>
  </section>

  <section>
    <title>Building a [[NAME]] application with Ant</title>

    <para></para>

    <section>
      <title>Creating a web-app</title>

      <para>From the same set of project files we can create a
      <emphasis>war</emphasis> file for running [[NAME]] on a web server
      such as Tomcat. Running Ant again with the <emphasis
      role="strong">web-app</emphasis> target will create war file in the
      <filename class="directory" moreinfo="none">dist</filename> directory.
      It is important to note that we do not need to provide and additional
      files or configurations to create the war.</para>

      <literallayout>$ ant web-app
Buildfile: build.xml

compile:
web-app:
    [mkdir] Created dir: /home/rcm/no-development/release-trial/office-workspace/build/war
    [unwar] Expanding: /home/rcm/tmp/release/developer/lib/nos-web-app-3.0M4D2-SNAPSHOT.war into /home/rcm/no-development/release-trial/office-workspace/build/war
      [war] Building war: /home/rcm/no-development/release-trial/office-workspace/dist/example.war
BUILD SUCCESSFUL
Total time: 5 seconds</literallayout>

      <para></para>

      <para></para>

      <para></para>

      <para></para>

      <para></para>

      <section>
        <title>Persistor</title>

        <literallayout>-r &lt;persistor&gt;
--persistor &lt;persistor&gt;</literallayout>

        <para>Ignored if type is client.</para>

        <para>The persistor option allows you to choose how the objects
        created by the system will be persisted so they are still available
        the next time you run the system. The following options are available
        with the current distribution, and if none is specified then the
        in-memory persistor will be used for exploration mode and xml
        persistor will be used for other non-client modes by default.</para>

        <para><emphasis>in-memory</emphasis> - A simple non-persisting
        mechanism that will only hold the persisted object while the virtual
        machine is running. This is used for testing and demonstrating.</para>

        <para><emphasis>xml</emphasis> - A simple file based mechanism that
        encodes each object's data in an XML file. Alongside the data files
        for the objects are instance lists listing all the files for each type
        of object.</para>

        <para><emphasis>sql</emphasis> - A simple JDBC based mechanism that
        creates basic tables for each object type and uses these to store the
        object's data.</para>

        <para><emphasis>hibernate</emphasis> - Interface to Hibernate ORM,
        allowing automatic persistence of an entire DOM with the power and
        flexibility that Hibernate provides.</para>

        <para><emphasis>&lt;class name&gt;</emphasis> - By specifying a class
        name the boot loader will load up that class as the persistor.</para>
      </section>

      <section>
        <title>Viewer</title>

        <literallayout>-v &lt;viewer&gt;
--viewer &lt;viewer&gt;</literallayout>

        <para>Ignored if type is server.</para>

        <para>The viewer option allows you to choose the user interface that
        is used to access your [[NAME]] application. The following
        options are available with the current distribution, and if none is
        specified then the drag and drop view will be used by default.</para>

        <para><emphasis>dnd</emphasis> - Drag and Drop viewer</para>

        <para><emphasis>cli</emphasis> - Console based Command Line
        Interface</para>

        <para><emphasis>cli-awt</emphasis> -Command Line Interface running via
        a basic Java AWT window</para>

        <para><emphasis>web</emphasis> - Web browser viewer - accessed via
        standard web browser such as FireFox, Internet Explorer or
        Opera</para>

        <para><emphasis>&lt;class name&gt;</emphasis> - By specifying a class
        name the boot loader will load up that class as the viewer</para>
      </section>
    </section>
  </section>

  <section>
    <title>User profiles</title>

    <para>Information about a user of the system (rather that a user of the
    application domain model) is stored in a <literal>UserProfile</literal>
    object which is got from the <literal>UserProfileService</literal>, which
    in turn is accessible from <literal>IsisSession</literal>. There is
    also convienence methods on <literal>IsisContext</literal> to get
    both the <literal>UserProfile</literal> and the
    <literal>UserProfileService</literal>. The user profile details the
    perspectives the user has set up and options that have been specified,
    typically for the user interfaces. The user profile service provides a way
    to create, save and retrieve the user profiles, specifically the profile
    of the current user. The service in turn has a
    <literal>UserProfilePersistor</literal> that is used to do the actual
    persistence.</para>

    <para>Setting up profiles</para>

    <para>Profiles can be created at start up by creating
    <literal>UserProfileFixture</literal> subclasses. Theses are only ever
    loaded once as the fixture installer checks with
    <literal>UserProfileSevice.isInitialized()</literal> to see if the service
    is already set up. The profile fixture (which is defined in the
    application library and is therefore not part of the [[NAME]]
    framework) loads the profiles into [[NAME]] by passing in an
    implementation of ProfilePersistor that provides a way for the perspective
    to make requests of the framework.</para>

    <para></para>

    <para></para>

    <para></para>
  </section>

  <section>
    <title>Working with the Hibernate Object Store</title>

    <para>In this section we look at how to store domain objects in a database
    using the Hibernate Object Store (HOS). Some knowledge of Hibernate is
    expected.</para>

    <para>The code used throughout this section can be found in the [[NAME]]
    Objects distribution download in the examples directory: <filename
    class="directory" moreinfo="none">examples/expenses</filename>. To run the
    examples execute the following command:</para>

    <literallayout>$ ant standalone-hibernate</literallayout>

    <para>All the other examples may also be run this way.</para>

    <para>The HSQLDB database is used to store the data under the <filename
    class="directory" moreinfo="none">tmp</filename> directory. If you wish to
    see what data has been loaded to the database, you can run the HSQLDB
    database manager using the following code. This tool can list the tables
    and their columns, and you can run SQL commands to query the tables. If
    you wish to reset the database to start again then simply delete this
    directory.</para>

    <literallayout>$ java -cp ..\..\lib\hsqldb-1.8.0.7.jar org.hsqldb.util.DatabaseManager</literallayout>

    <section>
      <title>Configuring the system to work with Hibernate</title>

      <para>The first step is to configure the HOS. This uses a configuration
      file <filename class="directory"
      moreinfo="none">hibernate.properties</filename>, as well as the normal
      <filename class="directory"
      moreinfo="none">isis.properties</filename>, and is loaded from
      the ClassPath. In addition, an optional <filename class="directory"
      moreinfo="none">logging.properties</filename> file may also be present.
      In order to automatically map your domain objects to a database schema,
      <literal>isis.persistence.hibernate.auto</literal> must be
      <emphasis>true</emphasis>, and the entity (domain) classes must be
      listed under
      <literal>isis.persistence.hibernate.classes</literal>. To see a
      full list of available properties, and their possible values see the
      section on Hibernate Object Store Properties.</para>

      <programlisting format="linespecific"># turn on automatic mapping of [[NAME]] to Hibernate
isis.persistence.hibernate.auto = true
# drop/recreate on setup
isis.persistence.hibernate.schema-export = true
# Hibernate type used to map List and InternalCollection. Allowed values list/bag
isis.persistence.hibernate.list = bag
# map collections as one-to-many or many-to-many? Allowed values one/many
isis.persistence.hibernate.collections = one
# assume relationships are bidirectional - i.e. map with inverse="true"
isis.persistence.hibernate.assumeBidirectional = true
# shutdown the DB - required for Derby, useful for HSQL as it compacts the files
isis.persistence.hibernate.shutdown = true

# classes which Hibernate must auto map
isis.persistence.hibernate.classes =  \
    org.apache.isis.object.application.BasicApplicationContext \
  , org.apache.isis.object.application.SimpleUser \
  , org.apache.isis.example.expenses.defaults.Claim \
  , org.apache.isis.example.expenses.defaults.Employee \
  , org.apache.isis.example.expenses.defaults.ExpenseType \
  , org.apache.isis.example.expenses.defaults.Item \
  , org.apache.isis.example.expenses.defaults.TemplateClaim \
  , org.apache.isis.example.expenses.item.Airfare \
  , org.apache.isis.example.expenses.item.CarRental \
  , org.apache.isis.example.expenses.item.GeneralExpense \
  , org.apache.isis.example.expenses.item.Hotel \
  , org.apache.isis.example.expenses.item.Journey \
  , org.apache.isis.example.expenses.item.Meal \
  , org.apache.isis.example.expenses.item.MobilePhone \
  , org.apache.isis.example.expenses.item.PrivateCarJourney \
  , org.apache.isis.example.expenses.item.Taxi \
  , org.apache.isis.example.expenses.item.Train

isis.services.prefix = \
   org.apache.isis.example.expenses.resources.hibernate
isis.services = HibernateClaimRepository \
  , HibernateEmployeeRepository \
  , HibernateExpenseTypeRepository \
  , HibernateItemRepository

isis.fixtures.prefix = \
    org.apache.isis.example.expenses.fixture
isis.fixtures = ExpenseTypes, Employees \
   , RichardPsExpenses, Context, CurrentUser</programlisting>

      <para>Note that <literal>isis.services</literal> is still
      required to specify which resources are loaded, but now we use Hibernate
      specific implementations. We will cover these later.</para>
    </section>

    <section>
      <title>Managing Hibernate Mapping Files</title>

      <para>There are a number of options for creating and managing Hibernate
      mapping files within the [[NAME]] framework.</para>

      <section>
        <title>Automatic</title>

        <para>Allow Hibernate to auto-generate the mapping files. These will
        then be stored in the export directory and reused each time the
        application is started. They can be regenerated either by deleting the
        mapping files from their export directory or by setting the regenerate
        flag.</para>
      </section>

      <section>
        <title>Manual</title>

        <para>Write the mapping files manually. They can then be placed in the
        export directory, or elsewhere on the classpath, and identified within
        the <filename class="directory"
        moreinfo="none">hibernate.cfg.xml</filename> file with a mapping tag
        (see below).</para>
      </section>

      <section>
        <title>Customised</title>

        <para>Allow Hibernate to auto generate the mapping files and then
        optimise these by hand.</para>

        <para>For both manual and customised files care should be taken not to
        set the regenerate flag if the files are being picked up from the
        export directory as they will be overwritten by new auto generated
        files.</para>
      </section>
    </section>

    <section>
      <title>Configuration options for Hibernate</title>

      <para>The Hibernate configuration uses the normal <filename
      class="directory" moreinfo="none">hibernate.cfg.xml</filename> file.
      This configures the database engine to use the specified file to store
      the database while running as an integral part of [[NAME]] (that
      is: not as a separate process).</para>

      <programlisting format="linespecific">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;
  &lt;session-factory&gt;
    &lt;property name="bytecode.use_reflection_optimizer"&gt;true&lt;/property&gt;

    &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
    &lt;property name="connection.username"&gt;sa&lt;/property&gt;
    &lt;property name="connection.password"&gt;&lt;/property&gt;
    &lt;property name="connection.url"&gt;jdbc:hsqldb:file:tmp/hsql-db&lt;/property&gt;
    &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;
       
    &lt;property name="current_session_context_class"&gt;
      org.hibernate.context.ThreadLocalSessionContext
    &lt;/property&gt;
        
    &lt;property name="connection.provider_class"&gt;
      org.hibernate.connection.C3P0ConnectionProvider
    &lt;/property&gt;
    &lt;property name="hibernate.c3p0.minSize"&gt;3&lt;/property&gt;
    &lt;property name="hibernate.c3p0.timeout"&gt;1000&lt;/property&gt;
  &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</programlisting>

      <para>If any entities are to be mapped without using the HOS automatic
      mapping then they should be specified here using <literal
      moreinfo="none">&lt;mapping&gt;</literal> tags, and a separate <filename
      class="directory" moreinfo="none">hbm.xml</filename> file created to
      define the mapping. You can also change the JDBC connection provider, or
      specify any other Hibernate configuration here, if required.</para>

      <para>The HOS requires that the
      <literal>current_session_context_class</literal> property must be left
      as
      <literal>org.hibernate.context.ThreadLocalSessionContext</literal>.</para>

      <section>
        <title>Connection Pooling</title>

        <para>C3po is used for connection pooling. When used with Hibernate
        c3po has two sets of configuration. The first within the <filename
        class="directory" moreinfo="none">hibernate.cfg.xml</filename> file.
        E.g.</para>

        <programlisting format="linespecific">&lt;property name="hibernate.c3p0.acquire_increment"&gt;1&lt;/property&gt; 
&lt;property name="hibernate.c3p0.idle_test_period"&gt;100&lt;/property&gt; &lt;!-- seconds --&gt; 
&lt;property name="hibernate.c3p0.max_size"&gt;90&lt;/property&gt; 
&lt;property name="hibernate.c3p0.max_statements"&gt;0&lt;/property&gt; 
&lt;property name="hibernate.c3p0.min_size"&gt;10&lt;/property&gt; 
&lt;property name="hibernate.c3p0.timeout"&gt;100&lt;/property&gt; &lt;!-- seconds --&gt; </programlisting>

        <para>And the second within the <filename class="directory"
        moreinfo="none">c3po.properties</filename> file. For example, these
        settings will help debug connection closure problems.</para>

        <programlisting format="linespecific">c3p0.debugUnreturnedConnectionStackTraces=true
c3p0.unreturnedConnectionTimeout=100</programlisting>

        <para>The <filename class="directory"
        moreinfo="none">c3po.properties</filename> file is optional as are all
        the c3po properties within <filename class="directory"
        moreinfo="none">hibernate.cfg.xml</filename>. Both files should be on
        the classpath, with the <filename class="directory"
        moreinfo="none">hibernate.cfg.xml</filename> file specifically in the
        resources directory. All properties default to values as described in
        the <ulink
        url="http://www.mchange.com/projects/c3p0/index.html#appendix_d">c3po
        documentation</ulink>. As your project approaches the deployment
        phase, c3po settings should be tuned for the particular configuration
        the system is running on.</para>
      </section>
    </section>

    <section>
      <title>Writing Hibernate repositories</title>

      <para>In the early stages of prototyping a domain model, it is common
      practice to use 'naive' implementations of repositories, that operate
      with all objects in memory. Subsequently, the prototype may be run with
      the HOS, in which case it is appropriate to replace some or all of those
      repository implementations with Hibernate-specific implementations,
      which use the power of the Hibernate Query Language and the database to
      perform queries. For the expenses prototype four Repositories were
      created under
      <literal>org.apache.isis.example.expenses.resources.naive</literal>.
      These classes provide simple implementations for retrieving objects by
      looping through all instances of a class, and comparing values (using an
      implementation of the provided Filter interface).</para>

      <para>For example, in <literal>NaiveEmployeeRepository</literal> the
      method to find an <literal>Employee</literal> by name is</para>

      <programlisting format="linespecific">public List&lt;Employee&gt; searchByName(@Named("Employee Name")final String name) {
        Filter filter = new Filter() {
            public boolean accept(Object pojo) {
                return ((Employee) pojo).getName().toLowerCase().indexOf(name.toLowerCase()) &gt;= 0;
            }
        };
        List&lt;Employee&gt; results = allMatches(Employee.class, filter, false);
        if (results.size() &gt; 20) {
            throw new ApplicationException("More than 20 matches  -  please narrow search criteria");
        }
        return results;
}</programlisting>

      <para>Whereas the implementation for HOS in
      <literal>HibernateEmployeeRepository</literal> uses a Hibernate
      <literal>Query</literal> to perform the same function.</para>

      <programlisting format="linespecific">public List&lt;Employee&gt; searchByName(String name) {
        Query query = createEntityQuery("lower(o.name) like ?", Employee.class).setString(0, name + "%").setMaxResults(20);
        List list = Arrays.asList(findByQuery(query, Employee.class));
        return new ArrayList&lt;Employee&gt;(list);
}</programlisting>

      <para>HOS provides a class to simplify creating repositories,
      <literal>org.apache.isis.nos.store.hibernate.service.hibernate.service.H</literal>
      <literal>ibernateFactoryAndRepository</literal>. These are based on the
      standard <literal>AbstractFactoryAndRepository</literal> but provide
      additional helper methods to find objects using a query string, a
      Hibernate Query, or Hibernate Criteria. It also provides methods to
      create a Hibernate Query or Criteria.</para>

      <para>Useful methods are:</para>

      <itemizedlist>
        <listitem>
          <para><literal moreinfo="none">find...()</literal> - there are a
          multitude of <literal moreinfo="none">find()</literal>methods. Some
          take a text query, others a Hibernate Query or Criteria (which can
          be created by one of the following methods).</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">createCriteria(final Class
          cls)</literal> - create a Hibernate Criteria for cls.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">createEntityQuery(final String
          whereClause, final Class cls)</literal> - create a Hibernate Query
          for cls, with the specified where clause.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">createCountQuery(final String
          whereClause, final Class cls)</literal> - create a <literal
          moreinfo="none">count(*)</literal> Hibernate Query for cls, with the
          specified where clause. These queries should be executed directly,
          or passed to <literal moreinfo="none">countNotZero(final Query
          query)</literal> to check if the returned count is not zero.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">createQuery(final String
          query)</literal> - create a Hibernate Query from a complete query
          string.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">findFirst..()</literal> - follows the
          same pattern as the <literal moreinfo="none">find()</literal>
          methods, except it will only return the first object returned from
          the query.</para>
        </listitem>
      </itemizedlist>

      <para>When using Hibernate Queries or Criteria, they should first be
      created using one of the <literal moreinfo="none">create()</literal>
      methods, any parameters should be set, and then the populated Query or
      Criteria can be passed to one of the <literal
      moreinfo="none">find()</literal> methods to return the required
      objects.</para>

      <para><emphasis role="strong">Note:</emphasis> where Hibernate Queries
      are created for the passed-in <literal moreinfo="none">cls</literal>
      parameter, and only a where clause is specified, then the alias of the
      object is <literal moreinfo="none">"o"</literal>, i.e. the generated
      query starts <literal moreinfo="none">"from org.apache.isis.ClassName
      as o"</literal></para>

      <para>If required, the Hibernate <literal>Session</literal> can also be
      obtained by calling <literal moreinfo="none">getSession()</literal>,
      which also ensures that there is an active transaction running. The
      <literal>Session</literal> can then be used to create
      <literal>Queries</literal> or <literal>Criteria</literal>, which can
      then be passed to one of the <literal moreinfo="none">find()</literal>
      methods. HOS will ensure the transaction is committed at the end of the
      NOF transaction.</para>
    </section>

    <section>
      <title>Coding requirements for domain objects</title>

      <para>When coding with Hibernate there are a few rules to follow for
      each domain class you wish to persist:</para>

      <section>
        <title>Provide a no-argument constructor</title>

        <para>The HOS requires that there is a no-argument constructor for
        each domain class. Java provides an implicit no-argument constructor,
        unless you have implemented a constructor with arguments, in which
        case you must provide an explicit no-argument constructor as well.
        Note, however, that it is not considered good practice within [[NAME]]
        Objects to use constructors at all - because objects created via
        constructors are unknown to the application container. If you need to
        create a new object within your application code, you should use the
        <literal moreinfo="none">newTransientInstance()</literal> or <literal
        moreinfo="none">newPersistentInstance()</literal>, which are provided
        on the <literal>DomainObjectContainer</literal> or on
        <literal>AbstractDomainObject</literal>.</para>
      </section>

      <section>
        <title>Provide an identifier property (optional)</title>

        <para>Hibernate requires an identifier property for each persistent
        entity. If no identifier property is specified for an entity then the
        HOS will generate one automatically, but it will be managed internally
        within [[NAME]] and not be visible either to users or to the
        application programmer. If you wish to have programmatic access to the
        identifier then you need to add an identifier property, which must be
        called <emphasis role="strong">id</emphasis>.</para>
      </section>

      <section>
        <title>Provide a title property (optional)</title>

        <para>The HOS will automatically, persist the object's title, based on
        the <literal moreinfo="none">title()</literal> method, or <literal
        moreinfo="none">toString()</literal>, to enable searching by
        title.</para>
      </section>

      <section>
        <title>Prefer non-final classes</title>

        <para>Final classes can't be lazy-loaded by Hibernate, so final
        classes cause a performance overhead. (Refer to Hibernate
        documentation for further information).</para>
      </section>

      <section>
        <title>Declare accessors and mutators for persistent fields
        (optional)</title>

        <para>Within [[NAME]] an accessor (or 'getter') is mandatory for
        any field which is to be made available to the user, and a mutator
        ('setter') is required, except for collections.</para>

        <para>Hibernate recommends accessing ALL persistent fields (including
        collections) using both an accessor and a mutator. When using HOS you
        have two options:</para>

        <itemizedlist>
          <listitem>
            <para>use <emphasis>field</emphasis> access by setting the
            <literal>isis.persistence.hibernate.valueFieldAccess</literal>
            and
            <literal>isis.persistence.hibernate.associationFieldAccess</literal>
            properties</para>
          </listitem>

          <listitem>
            <para>create get() and set() methods for all persistent fields,
            including collections. By following the [[NAME]] coding style
            you should already have these for all value and object properties
            These methods may be private or protected.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Avoid accessor/mutator pairs on interfaces when auto generating
        mapping files.</title>

        <para>The hibernate mapping generation code in [[NAME]] may bring
        interfaces into the mapping class hierarchy. If this happens it will
        try to access any field identified by standard bean accessor/mutator
        methods (i.e. get&lt;Field&gt; and set&lt;Field&gt;) on the interface.
        Since this field does not exist on the interface this will cause an
        error. Typically this won't happen as interfaces are not included in
        the hierarchy - but it's best to avoid anyway as changes to the class
        hierarchy may bring interfaces in, in a non-obvious way. Not having
        both methods or renaming them will avoid this issue.</para>
      </section>

      <section>
        <title>Collections</title>

        <para>Collections must be declared using the interface type, e.g.
        <literal moreinfo="none">java.util.List</literal> rather than a
        concrete type such as <literal>java.util.ArrayList</literal>.
        Currently <literal>List</literal> is the only supported collection
        type within [[NAME]], however you may also use arrays.</para>
      </section>

      <section>
        <title>Version and Modification properties (optional)</title>

        <para>For every domain object, [[NAME]] creates a version number,
        as well as modified by user and time, and associates this with the
        object internally. The HOS will create additional columns on the
        database to hold this information, as needed by the framework. If you
        wish to have this information explicitly accessible as properties on
        your objects you need to add the following properties in <filename
        class="directory"
        moreinfo="none">hibernate.properties</filename>:</para>

        <itemizedlist>
          <listitem>
            <para><literal>isis.persistence.hibernate.version</literal>
            for the name of the version number property. This must be a
            java.lang.Long.</para>
          </listitem>

          <listitem>
            <para><literal>isis.persistence.hibernate.modified_by</literal>
            for the userid of the last person to modify an object. This should
            be a string.</para>
          </listitem>

          <listitem>
            <para><literal>isis.persistence.hibernate.modified_on</literal>
            for the date the object was last updated. This should be a
            java.util.Date</para>
          </listitem>
        </itemizedlist>

        <para>Note: these are system wide values, so if you use this feature
        you must use a consistent naming scheme across your objects.</para>

        <para>Each of these values is optional. By default these properties
        are accessed using the setting of
        <literal>isis.persistence.hibernate.valueFieldAccess</literal>.
        To specify a different access mechanism, each of these properties has
        an associated <literal>.access</literal> property, for example
        <literal>isis.persistence.hibernate.version.access</literal>.
        This can be set to the Hibernate access type, namely <literal
        moreinfo="none">field</literal>, <literal
        moreinfo="none">property</literal> or <literal
        moreinfo="none">ClassName</literal>.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Running client-server</title>

    <para></para>

    <section>
      <title>Specifying Hibernate for persistence</title>

      <para>The above examples provide basic persistence via a file based
      (XML) persistence layer. To use a persistence layer based on Hibernate a
      small amount of configuration is required. First copy across the
      Hibernate configuration file - <filename class="directory"
      moreinfo="none">hibernate.cfg.xml</filename> - from the distribution's
      resource directory. In its newly copied state this file specifies that
      the database is HSQLDB, but it does contain other configurations that
      can be uncommented so you can use other databases such as MySQL or
      SQLServer.</para>

      <literallayout>resources/
   <emphasis role="strong">hibernate.cfg.xml</emphasis>
   :</literallayout>

      <para>The only other task is to list the classes that need to be mapped
      to database tables so that object store can set up the database and
      create the Hibernate mappings for you. This list need only name the root
      objects as any reachable class will also be mapped. This can be added to
      the <filename class="directory"
      moreinfo="none">isis.properties</filename> file. Alternatively a
      new file, <filename class="directory"
      moreinfo="none">hibernate.properties</filename>, may be added to the
      <filename class="directory" moreinfo="none">config</filename> directory,
      which will only be loaded when the Hibernate persistor is used. The
      following properties setting registers two classes that are to be
      persisted using Hibernate.</para>

      <programlisting format="linespecific">isis.persistence.hibernate.classes = example.dom.Contact, example.dom.PhoneNumber</programlisting>

      <para>To run [[NAME]] with the Hibernate persistor change the
      persistor type to <emphasis role="strong">hibernate</emphasis> when
      starting up [[NAME]]. The following shows the integrated web server
      from above being run with the Hibernate persistor.</para>

      <literallayout>$ isis.sh --type server --viewer html <emphasis
          role="strong">--persistor hibernate</emphasis>
   </literallayout>

      <para>During start up the Hibernate persistor will generate Hibernate
      mapping files and add them to a newly created directory called <filename
      class="directory" moreinfo="none">mappings</filename>. Assuming that you
      used the default configuration in <filename class="directory"
      moreinfo="none">hibernate.cfg.xml</filename> the HSQLDB engine will be
      used and a directory, <filename class="directory"
      moreinfo="none">hsql</filename>, will be created to contain the files.
      For more information see Working with the Hibernate Object Store.</para>
    </section>
  </section>

  <section>
    <title>Recognised Methods (Prior to Java 1.5)</title>

    <para>If you are not using Java 1.5 then the methods in this section can
    be used instead of the annotations described in the next section. Note
    that not all annotations have a non-Java-1.5 equivalent.</para>

    <para>singularName</para>

    <para>pluralName</para>

    <para>markDirty</para>

    <para>clearDirty</para>

    <para>isDirty</para>

    <para>optional</para>

    <section>
      <title>Field order</title>

      <para>An order for the fields can specified via a method with the field
      order method.</para>

      <programlisting format="linespecific">public static String fieldOrder()</programlisting>

      <para>The method should return a comma separated list of field names
      (which are case and space insensitive) with the names listed in the
      order they should be used.</para>
    </section>

    <section>
      <title>Action order</title>

      <para>An order for the action can specified via a method with the action
      order method.</para>

      <programlisting format="linespecific">public static String actionOrder()</programlisting>

      <para>The method should return a comma separated list of action names
      (which are case and space insensitive) with the names listed in the
      order they should be used. Actions can be grouped together by
      surrounding the group with brackets ('(' and ')') and prefixing the
      group with name and colon, e.g. "(group name: first name, second name,
      etc)".</para>
    </section>

    <section>
      <title>Descriptive controls</title>

      <para>Field and action names are normally derived from the name of the
      method, but this can be changed. Also descriptions and help text can be
      provided from within the domain classes. The following signatures are
      recognised and used to get a name, description or help text for fields
      or actions.</para>

      <programlisting format="linespecific">public static String name&lt;fieldName&gt;([&lt;field type&gt; param])
public static String description&lt;fieldName&gt;([&lt;field type&gt; param])
public static String help&lt;fieldName&gt;([&lt;field type&gt; param])

public static String name&lt;actionName&gt;([&lt;parameter type&gt; param]...)
public static String description&lt;actionName&gt;([&lt;parameter type&gt; param]...)
public static String help&lt;actionName&gt;([&lt;parameter type&gt; param]...)</programlisting>

      <para>The parameters in an action can be labeled as a complete
      set.</para>

      <programlisting format="linespecific">public static String[] names&lt;actionName&gt;([&lt;parameter type&gt; param]...)</programlisting>
    </section>

    <section>
      <title>Static controls</title>

      <para>Specific fields can be hidden from the user; they are deemed to be
      internal to the object.</para>

      <programlisting format="linespecific">public static boolean alwaysHide&lt;fieldName&gt;([&lt;field type&gt; param])</programlisting>

      <para>Fields and action parameters can be flagged as required, so that
      the object is not valid, or the action cannot be invoked until the
      field/parameters are set.</para>

      <programlisting format="linespecific">public static boolean optional&lt;fieldName&gt;(&lt;field type&gt; param)

public static boolean[] optional&lt;actionName&gt;([&lt;parameter type&gt; param]...)</programlisting>
    </section>
  </section>

  <section>
    <title>Ant build.xml Template</title>

    <programlisting format="linespecific">&lt;?xml version="1.0"?&gt;

&lt;project name="[[NAME]] Example" default="dnd" basedir="."&gt;
    &lt;property name="lib.dir" value="../../lib" /&gt;
    &lt;property name="resource.dir" value="../../resources" /&gt;
    &lt;property name="build.dir" value="./build" /&gt;
    &lt;property name="dist.dir" value="./dist" /&gt;
    &lt;property name="classes.dir" value="./build/classes" /&gt;
    &lt;property name="war.dir" value="${build.dir}/war" /&gt;
    &lt;property name="src.dir" value="/src/" /&gt;
    &lt;property name="compile.target" value="1.5" /&gt;
    &lt;property name="source.target" value="1.5" /&gt;
    &lt;property name="bootclass" value="org.apache.isis.nof.boot.Isis" /&gt;
    &lt;property name="application.name" value="no-application" /&gt;

    &lt;target name="clean"&gt;
        &lt;delete dir="${build.dir}" failonerror="false" /&gt;
        &lt;delete dir="${dist.dir}" failonerror="false" /&gt;
    &lt;/target&gt;

    &lt;fileset dir="${lib.dir}" id="libs.set"&gt;
        &lt;include name="**/*.jar" /&gt;
    &lt;/fileset&gt;

    &lt;path id="libs.path"&gt;
        &lt;fileset refid="libs.set" /&gt;
    &lt;/path&gt;

    &lt;import file="./packages.xml" /&gt;

    &lt;target name="compile" description="Compile example"&gt;
        &lt;mkdir dir="${build.dir}" /&gt;
        &lt;mkdir dir="${classes.dir}" /&gt;

        &lt;javac destdir="${classes.dir}" target="${compile.target}" source="${source.target}"&gt;
            &lt;src refid="source.path" /&gt;
            &lt;classpath refid="libs.path" /&gt;
        &lt;/javac&gt;
    &lt;/target&gt;

    &lt;target name="dist" depends="compile" description="Collects together files for distribution"&gt;
        &lt;copy todir="${build.dir}/lib"&gt;
            &lt;fileset refid="libs.set" /&gt;
        &lt;/copy&gt;
        &lt;mkdir dir="${build.dir}/images" /&gt;
        &lt;copy todir="${build.dir}"&gt;
            &lt;fileset dir="."&gt;
                &lt;include name="config/*" /&gt;
                &lt;include name="resources/*" /&gt;
                &lt;include name="images/*" /&gt;
            &lt;/fileset&gt;
            &lt;fileset dir="${resource.dir}"&gt;
                &lt;include name="web/*" /&gt;
                &lt;include name="isis.*" /&gt;
                &lt;include name="lcp.bat" /&gt;
            &lt;/fileset&gt;
        &lt;/copy&gt;
        &lt;chmod file="${build.dir}/isis.sh" perm="ugo+x" /&gt;

        &lt;mkdir dir="${dist.dir}" /&gt;
        &lt;zip destfile="${dist.dir}/${application.name}.zip"&gt;
            &lt;zipfileset dir="${build.dir}" prefix="${application.name}"&gt;
                &lt;exclude name="isis.sh" /&gt;
            &lt;/zipfileset&gt;
            &lt;zipfileset dir="${build.dir}" filemode="755" prefix="${application.name}"&gt;
                &lt;include name="isis.sh" /&gt;
            &lt;/zipfileset&gt;
        &lt;/zip&gt;
    &lt;/target&gt;

    &lt;target name="exploration-dnd" depends="compile" description="Explore example using drag-and-drop graphical viewer"&gt;
        &lt;java fork="yes" classname="${bootclass}"&gt;
            &lt;classpath path="${classes.dir}" /&gt;
            &lt;classpath refid="libs.path" /&gt;
            &lt;classpath path="resources" /&gt;
            &lt;arg line="--type exploration --viewer dnd" /&gt;
        &lt;/java&gt;
    &lt;/target&gt;

    &lt;target name="exploration-web" depends="compile" description="Explore example using command-line viewer"&gt;
        &lt;java fork="yes" classname="${bootclass}"&gt;
            &lt;classpath path="${classes.dir}" /&gt;
            &lt;classpath refid="libs.path" /&gt;
            &lt;classpath path="resources" /&gt;
            &lt;arg line="--type exploration --viewer html" /&gt;
        &lt;/java&gt;
    &lt;/target&gt;

    &lt;target name="dnd" depends="compile" description="Run example using drag and drop viewer"&gt;
        &lt;java fork="yes" classname="${bootclass}"&gt;
            &lt;classpath path="${classes.dir}" /&gt;
            &lt;classpath refid="libs.path" /&gt;
            &lt;classpath path="resources" /&gt;
            &lt;arg line="--type prototype --viewer dnd" /&gt;
        &lt;/java&gt;
    &lt;/target&gt;

    &lt;target name="html" depends="compile" description="Run example using web viewer"&gt;
        &lt;java fork="yes" classname="${bootclass}"&gt;
            &lt;classpath path="${classes.dir}" /&gt;
            &lt;classpath refid="libs.path" /&gt;
            &lt;classpath path="resources" /&gt;
            &lt;arg line="--type prototype --viewer html" /&gt;
        &lt;/java&gt;
    &lt;/target&gt;

    &lt;target name="standalone-xml" depends="compile" description="Run standalone with xml persistence"&gt;
        &lt;java fork="yes" classname="${bootclass}"&gt;
            &lt;classpath path="${classes.dir}" /&gt;
            &lt;classpath refid="libs.path" /&gt;
            &lt;classpath path="resources" /&gt;
            &lt;arg line="--type standalone --viewer dnd --persistor xml" /&gt;
        &lt;/java&gt;
    &lt;/target&gt;

    &lt;target name="standalone-hibernate" depends="compile" description="Run standalone with hibernate persistence"&gt;
        &lt;java fork="yes" classname="${bootclass}"&gt;
            &lt;classpath path="${classes.dir}" /&gt;
            &lt;classpath refid="libs.path" /&gt;
            &lt;classpath path="resources" /&gt;
            &lt;arg line="--type standalone --viewer dnd --persistor hibernate" /&gt;
        &lt;/java&gt;
    &lt;/target&gt;

&lt;/project&gt;</programlisting>
  </section>

  <section>
    <title>Configuration</title>

    <para></para>

    <section>
      <title>Hibernate Object Store Properties</title>

      <para>The behaviour of the Hibernate Object Store can be tailored using
      properties as detailed below. All properties have a common root of
      <literal>isis.persistence.hibernate</literal>.</para>

      <para>By default, when running with command line option <literal
      moreinfo="none">-r hibernate</literal> properties are loaded from
      configuration <emphasis role="strong">isis.properties,
      hibernate.properties</emphasis> and <emphasis
      role="strong">logging.properties</emphasis> which are located on the
      classpath. All examples are given using standard Java.</para>

      <section>
        <title>Automatic mapping</title>

        <para>To automatically map [[NAME]] as persistent Hibernate
        entities <literal>auto</literal> property must be set.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.auto = true</programlisting>

        <para>Once generated the mapping files will be reused each time the
        application is started unless the <literal>regenerate</literal>
        property is set. Which will force the mapping files to be regenerated
        each time</para>

        <programlisting format="linespecific">isis.persistence.hibernate.regenerate = true</programlisting>

        <para>Mapping files are written and read from the location (under the
        application root) given in the <literal>hbm-export</literal>
        property.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.hbm-export = mappings</programlisting>
      </section>

      <section>
        <title>Specifying mapped persistent classes</title>

        <para>The list of persistent classes which will be automatically
        mapped is specified by the <literal>classes</literal> property. Any
        related entity classes in each class's hierarchy will be automatically
        picked up as necessary, however it is preferred to explicitly list all
        persistent classes.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.classes = \
    org.apache.isis.object.application.BasicApplicationContext \
  , org.apache.isis.object.application.SimpleUser \
  , org.apache.isis.example.ecs.Customer \
  , org.apache.isis.example.ecs.Location \
  , org.apache.isis.example.ecs.City
  , org.apache.isis.example.ecs.Telephone \
  , org.apache.isis.example.ecs.CreditCard \
  , org.apache.isis.example.ecs.resources.ReferenceGenerator</programlisting>

        <para>As a shortcut you can specify the prefix for all classes listed
        in the <literal>classes</literal> property using
        <literal>classes.prefix</literal>.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.classes.prefix = \
  org.apache.isis.example.ecs
isis.persistence.hibernate.classes = Customer, Location \
    , City, Telephone, CreditCard, resources.ReferenceGenerator</programlisting>
      </section>

      <section>
        <title>Checking if the Object Store is initialized</title>

        <para>Fixtures are run, and the database tables created, only when an
        Object Store is not initialized. By default the HOS is defined to be
        initialized if any of the mapped tables exists, with the specific
        table selected at random from the classes mapped to the
        database.</para>

        <para>This behaviour can be overridden is several ways.</para>

        <para>To explicitly specify if the HOS is initialized set the
        <literal>initialized</literal> property.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.initialized = false</programlisting>

        <para>To allow the Object Store to determine if it is initialized by
        checking the existence of a specific table then you can specify the
        catalog, schema and table using the
        <literal>initialized.catalog</literal>,
        <literal>initialized.schema</literal> and
        <literal>initialized.table</literal>properties. Depending on your
        database, only <literal>initialized.table</literal> is
        required.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.schema = MYSCHEMA
isis.persistence.hibernate.table = MYTABLE</programlisting>
      </section>

      <section>
        <title>Creating database tables</title>

        <para>Hibernate contains tools which can be used to create the
        database schema. If the Object Store is not initialized (see above),
        and the <literal>schema-export</literal> property is set, then the
        database tables are created automatically using the Hibernate <literal
        moreinfo="none">SchemaExport</literal> tool.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.schema-export = true</programlisting>
      </section>

      <section>
        <title>Updating the database schema</title>

        <para>If the HOS is initialized (see above) the database schema can be
        updated automatically to keep in line with any changes to the domain
        model. This functionality is used the Hibernate <literal
        moreinfo="none">SchemaUpdate</literal> tool, and is specified by
        setting the <literal>schema-update</literal> property. Current
        limitations of this tool should be checked from Hibernate
        documentation.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.schema-update = true</programlisting>
      </section>

      <section>
        <title>Save/update/delete behaviour</title>

        <para>Within NOF, save, update and delete requests are stored within a
        NOF transaction, and only submitted to the database at the end of the
        NOF transaction. This can obviously cause issues, for example when
        looking up an object in the database that was saved during the same
        session. Therefore, by default the Hibernate Object Store executes
        save/update/deletes as necessary (typically triggered by queries). To
        revert to normal NOF behaviour set the
        <literal>saveImmediate</literal> property to
        <emphasis>false</emphasis>.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.saveImmediate = false</programlisting>
      </section>

      <section>
        <title>Database shutdown</title>

        <para>Some databases require certain routines to be run when the
        application shuts down. To specify that this occurs set the
        <literal>shutdown</literal> property to
        <emphasis>true</emphasis>.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.shutdown = true</programlisting>

        <para>At [[NAME]] shutdown, this has the following effects for
        the specified databases:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Apache Derby</emphasis>: calls
            <literal>DriverManager.getConnection("jdbc:derby:;shutdown=true");</literal>
            to shutdown the database correctly.</para>
          </listitem>

          <listitem>
            <para><emphasis>HSQLDB</emphasis>: runs the <literal
            moreinfo="none">SHUTDOWN COMPACT</literal> SQL command to
            correctly organise and compact the database.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>List behaviour</title>

        <para>By default any persistent collections of type
        <literal>java.util.List</literal> are mapped using Hibernate bag
        semantics, that is to say that list order is not preserved. In order
        to change behaviour set the <literal>list</literal> property to
        <emphasis>list</emphasis>. This will change the mapping to use
        Hibernate list semantics, and will generate a
        <emphasis>position</emphasis> column on the database. The default
        setting is <emphasis>bag</emphasis>.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.list = list</programlisting>
      </section>

      <section>
        <title>Collection behaviour</title>

        <para>By default persistent collections are modelled using a
        one-to-many association. Hibernate maps this type of association by
        linking the tables of two classes via a foreign key, with no
        intervening collection table. Hibernate can also map collections as
        many-to-many associations, which requires a dedicated collection
        table. In order to map collections using many-to-many associations set
        the <literal>collections</literal> property to
        <emphasis>many</emphasis>. The default setting is
        <emphasis>one</emphasis>.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.collections = many</programlisting>
      </section>

      <section>
        <title>Property or field access</title>

        <para>Hibernate has alternative strategies for accessing properties of
        persistent entities. By default all properties are accessed using
        Hibernate's <emphasis>property</emphasis> access method, that is to
        say via <literal>get()</literal> and <literal>set()</literal> methods.
        In a [[NAME]] system, when Hibernate loads or saves an object
        this will mean getters will call <literal>resolve()</literal> and
        setters <literal>objectChanged()</literal>. The Hibernate Object Store
        will ignore these calls, but obviously this does cause some overhead.
        In order to access the fields directly, and so bypass the getters and
        setters, Hibernate also provides a <emphasis>field</emphasis> access
        method. There are two properties to use, set
        <literal>valueFieldAccess</literal> for Hibernate to access values and
        relationships to single objects directly, and
        <literal>associationFieldAccess</literal> for Hibernate to access
        collections directly.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.valueFieldAccess = true
isis.persistence.hibernate.associationFieldAccess = true</programlisting>

        <para>Note: if you set either of these properties then you must ensure
        that the field names in your object match the property names, i.e.
        <literal moreinfo="none">String xxx;</literal> and
        <literal>getXxx()</literal>. If all fields have a specific prefix you
        can set it using the <literal>fieldPrefix</literal> property. So, if
        in the above example the field was actually <literal
        moreinfo="none">String _xxx;</literal> the setting would be</para>

        <programlisting format="linespecific">isis.persistence.hibernate.fieldPrefix = _</programlisting>
      </section>

      <section>
        <title>Bidirectional associations</title>

        <para>You can tell the Hibernate Object Store to assume that a
        bidirectional relationship between two [[NAME]], that is where
        the association can be navigated in both directions, should be mapped
        as a bidirectional Hibernate association. This will only occur in the
        following circumstances: for [[NAME]] A and B, A must have one
        and only one association to B, and B have one and only one association
        to A.</para>

        <para>By setting property <literal>assumeBidirectional</literal>
        entities will be mapped using <literal
        moreinfo="none">inverse="true"</literal> in Hibernate terms.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.assumeBidirectional = true</programlisting>
      </section>

      <section>
        <title>Changing column names</title>

        <para>By default properties are mapped to columns of the same name.
        This may cause database errors if properties have the same name as a
        database reserved word (although the mapping code will attempt to
        preempt collisions by renaming columns that have the same name as a
        database keyword), or you may simply wish to map a property to a
        different column. To change the column name for a particular property
        name set the <literal>column.&lt;property-name&gt;</literal> property
        to the column name, for example <literal
        moreinfo="none">temporary</literal> is a reserved word in the Derby
        database, so to map this to a column called temp use the
        following:</para>

        <programlisting format="linespecific">isis.persistence.hibernate.column.temporary = temp</programlisting>

        <para>When the [[NAME]] identifies database keyword collisions in
        database table and column names it will append a suffix. By default
        this is '_TABLE' and '_column' respectively but this can be controlled
        by properties as follows.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.reservedColumnNameSuffix = _TABLE
isis.persistence.hibernate.reservedTableNameSuffix = _column</programlisting>
      </section>

      <section>
        <title>Version and modified information</title>

        <para>NOF holds version and modification information externally to an
        object. This is especially important for client-server set ups.
        However, using HOS it is also possible to hold this information as
        properties of a [[NAME]]. To specify which properties match the
        NOF version/modified data you can specify 3 properties, whose values
        are the property names on your object:</para>

        <itemizedlist>
          <listitem>
            <para><literal>version</literal> for version number. This must be
            a java.lang.Long.</para>
          </listitem>

          <listitem>
            <para><literal>modified_by</literal> for the userid of the last
            person to modify an object. This should be a string.</para>
          </listitem>

          <listitem>
            <para><literal>modified_on</literal> for the date the object was
            last updated. This should be a java.util.Date</para>
          </listitem>
        </itemizedlist>

        <para>Note: these are system wide values, so to use this feature you
        must use a consistent naming scheme across your objects. By default
        these properties are accessed using the setting of
        <literal>valueFieldAccess</literal> above. To specify a different
        access mechanism, each of these properties has an associated
        <literal>.access</literal> property, for example
        <literal>version.access</literal>. This can be set to the Hibernate
        access type, namely <literal moreinfo="none">field</literal>, <literal
        moreinfo="none">property</literal> or <literal
        moreinfo="none">ClassName</literal>.</para>

        <programlisting format="linespecific">isis.persistence.hibernate.modified_on = lastUpdated
isis.persistence.hibernate.modified_on.access = property</programlisting>
      </section>
    </section>
  </section>
</article>
