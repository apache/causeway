= Shiro Security

:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:page-partial:


This guide describes the design and configuration of the Apache Shiro integration with Apache Isis.


== Design

The Shiro integration provides an implementation for both the
xref:refguide:core:index/security/authentication/Authenticator.adoc[Authenticator] and xref:refguide:core:index/security/authorization/Authorizor.adoc[Authorizor] SPIs.
These both delegate to Shiro's `SubjectUtils` class that in turn delegates to the `SecurityManager`.
These are available as thread-locals (set up in a servlet filter):

.High-level design of the Shiro integration
image::shiro-design.drawio.svg[]

Shiro's link:http://shiro.apache.org/static/latest/apidocs/org/apache/shiro/subject/Subject.html[Subject] API defines the notion of a user, and uses the concept of a https://shiro.apache.org/static/1.7.1/apidocs/org/apache/shiro/realm/Realm.html[Realm] as the means to authenticate the ``Subject``s and optionally populate it with permissions.

Shiro ships with a simple text-based realm -- the `IniRealm` -- which reads users (and password), user roles and role permissions from the `shiro.ini` file.
Configuring this realm is described <<shiro-ini-realm,below>>

TIP: The xref:docs:starters:helloworld.adoc[HelloWorld] and xref:docs:starters:simpleapp.adoc[SimpleApp] starter apps are both configured to use this realm.

A more sophisticated option is the LDAP realm.
Shiro has its own implementation which is extended in the  provides the xref:security:shiro-realm-ldap:about.adoc[LDAP realm]
This realm also supports permissions.

Permissions are ultimately represented as strings, and their interpretation of them is the responsibility of `AuthorizorShiro`.
An enhanced "wildcard" syntax, described  <<enhanced-wildcard-permission,below>> in more detail, incorporates the notion of read and write permissions, and also of vetoing permissions (as well as the usual allow permissions).


[[configuring-isis-to-use-shiro]]
== Configuring to use Shiro

Apache Isis' security mechanism is configurable, specifying an `Authenticator` and an `Authorizor` (non-public) APIs.
The Shiro security mechanism is an integration with Apache Shiro that implements both interfaces.

[TIP]
====
Both the xref:docs:starters:helloworld.adoc[HelloWorld] and xref:docs:starters:simpleapp.adoc[SimpleApp] starter apps are pre-configured to use Apache Shiro, so much of what follows may well have been set up already.
====

include::docs:mavendeps:partial$setup-and-configure-mavendeps-webapp.adoc[leveloffset=+1]


=== Update AppManifest

In your application's `AppManifest` (top-level Spring `@Configuration` used to bootstrap the app), import the

[source,java]
.AppManifest.java
----
@Configuration
@Import({
        ...
        IsisModuleSecurityShiro.class,
        ...
})
public class AppManifest {
}
----

Make sure that no other `IsisModuleSecurityXxx` module is imported.

=== Configuration Properties

The Shiro integration supports the following config properties:

* xref:refguide:config:sections/isis.security.shiro.adoc#isis.security.shiro.auto-logout-if-already-authenticated[isis.security.shiro.auto-logout-if-already-authenticated]

=== Shiro Realms and shiro.ini

Shiro uses the concept of realms to define its own set of authenticated users and their roles.
Either one or many realms can be configured.

The `shiro.ini` file is used to define which realm are to be used.
This resides in the default package (in other words, in `src/main/resources` in the webapp module).

[source,ini]
----
securityManager.realms = $realmName
----

Shiro's ini file supports a "poor-man's" dependency injection (link:https://shiro.apache.org/configuration.html[their words]), and so `$realmName` in the above example is a reference to a realm defined elsewhere in `shiro.ini`.

It's also possible to configure Shiro to support multiple realms.

[source,ini]
----
securityManager.realms = $realm1,$realm2
----

How to configure the text-based ini realm is explained <<shiro-ini-realm,below>>.
Another option lternative is the xref:security:shiro-realm-ldap:about.adoc[LDAP realm].

To leverage Apache Isis' <<enhanced-wildcard-permission,enhanced wildcard permissions>>, you should also specify the Apache Isis permission resolver for the specified realm; further details <<permission-resolver-configuration,below>>.



[#shiro-ini-realm]
== Shiro Ini Realm

The Shiro concept of a `Realm` allows different implementations of both the authentication and authorisation mechanism to be plugged in.

The simplest realm to use is Shiro's built-in `IniRealm`, which reads from the (same) `shiro.ini` file.

image::ini/shiro-ini-realm.drawio.svg[]

This is suitable for prototyping, but isn't intended for production use, if only because user/password credentials are stored in plain text.
Nevertheless, it's a good starting point.
The app generated by both the xref:docs:starters:helloworld.adoc[HelloWorld] and xref:docs:starters:simpleapp.adoc[SimpleApp] starter apps are configured to use this realm.



=== Shiro Configuration

To use the built-in `IniRealm`, we add the following to `shiro.ini`:

[source,ini]
----
securityManager.realms = $iniRealm
----

(Unlike other realms) there is no need to "define" `$iniRealm`; it is automatically available to us.

Specifying `$iniRealm` means that the usernames/passwords, roles and permissions are read from the `shiro.ini` file itself.
Specifically:

* the users/passwords and their roles from the `[users]` sections;
* the roles are mapped to permissions in the `[roles]` section.

The format of these is described below.

==== `[users]` section

This section lists users, passwords and their roles.

For example:

[source,ini]
----
sven = pass, admin_role
dick = pass, user_role, analysis_role, self-install_role
bob  = pass, user_role, self-install_role
----

The first value is the password (eg "pass", the remaining values are the role(s).

==== `[roles]` section

This section lists roles and their corresponding permissions.

For example:

[source,ini]
----
user_role = *:ToDoItems:*:*,\
            *:ToDoItem:*:*,\
            *:TodoAppDashboard:*:*
analysis_role = *:ToDoItemAnalysis:*:*,\
            *:ToDoItemsByCategoryViewModel:*:*,\
            *:ToDoItemsByDateRangeViewModel:*:*
self-install_role = *:ToDoItemsFixturesService:install:*
admin_role = *
----

The value is a comma-separated list of permissions for the role.
The format is:

[source,ini]
----
packageName:className:memberName:r,w
----

where:

* `memberName` is the property, collection or action name.
* `r` indicates that the member is visible
* `w` indicates that the member is usable (editable or invokable)

and where each of the parts of the permission string can be wildcarded using `*`.

Because these are wildcards, a '*' can be used at any level.
Additionally, missing levels assume wildcards.

Thus:

[source,ini]
----
com.mycompany.myapp:Customer:firstName:r,w   # view or edit customer's firstName
com.mycompany.myapp:Customer:lastName:r      # view customer's lastName only
com.mycompany.myapp:Customer:placeOrder:*    # view and invoke placeOrder action
com.mycompany.myapp:Customer:placeOrder      # ditto
com.mycompany.myapp:Customer:*:r             # view all customer class members
com.mycompany.myapp:*:*:r                    # view-only access for all classes in myapp package
com.mycompany.myapp:*:*:*                    # view/edit for all classes in myapp package
com.mycompany.myapp:*:*                      # ditto
com.mycompany.myapp:*                        # ditto
com.mycompany.myapp                          # ditto
*                                            # view/edit access to everything
----

[TIP]
====
The format of the permissions string is configurable in Shiro, and Apache Isis uses this to provide an extended wildcard format, described xref:security:shiro:about.adoc#enhanced-wildcard-permission[here].
====

=== Externalized IniRealm

There's no requirement for all users/roles to be defined in the `shiro.ini` file.
Instead, a realm can be defined that loads its users/roles from some other resource.

For example:

[source,ini]
----
$realm1=org.apache.shiro.realm.text.IniRealm # <1>
realm1.resourcePath=classpath:webapp/realm1.ini # <2>
----
<1> happens to (coincidentally) be the link:http://shiro.apache.org/static/latest/apidocs/org/apache/shiro/realm/text/IniRealm.html[same implementation] as Shiro's built-in $iniRealm
<2> in this case load the users/roles from the `src/main/resources/webapp/realm1.ini` file.

Note that a URL could be provided as the `resourcePath`, so a centralized config file could be used.
Even so, the

[NOTE]
====
If configured this way then the `[users]` and `[roles]` sections of `shiro.ini` become unused.
Instead, the corresponding sections from for `realm1.ini` are used instead.
====


//== Shiro JDBC Realm
//
//There is nothing to stop you from using some other `Realm` implementation (or indeed writing one yourself).
//For example, you could use Shiro's own JDBC realm that loads user/password details from a database.
//
//[WARNING]
//====
//If you are happy to use a database then we strongly recommend you use the xref:security:ROOT:about.adoc[SecMan extension] instead of a vanilla JDBC; it is far more sophisticated and moreover gives you the ability to administer the system from within your Apache Isis application.
//====
//
//If you go down this route, then the architecture is as follows:
//
//image::configuration/configuring-shiro/jdbc/configure-shiro-to-use-custom-jdbc-realm.png[width="600px"]
//
//
//
//
//There's quite a lot of configuration required (in `shiro.ini`) to set up a JDBC realm, so we'll break it out into sections.
//
//First, we need to set up the connection to JDBC:
//
//[source,ini]
//----
//jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm        # <.>
//
//jof = org.apache.shiro.jndi.JndiObjectFactory          # <.>
//jof.resourceName = jdbc/postgres                       # <.>
//jof.requiredType = javax.sql.DataSource
//jof.resourceRef = true
//
//jdbcRealm.dataSource = $jof                            # <4>
//----
//<1> instantiate the JDBC realm
//<2> instantiate factory object to lookup DataSource from servlet container
//<3> name of the datasource (as configured in `web.xml`)
//<4> instruct JDBC realm to obtain datasource from the JNDI
//
//
//We next need to tell the realm how to query the database.Shiro supports any schema; what matters is the input search argument and the output results.
//
//[source,ini]
//----
//
//jdbcRealm.authenticationQuery =         \              # <1>
//        select password                 \
//          from users                    \
//         where username = ?
//
//jdbcRealm.userRolesQuery =              \              # <2>
//        select r.label                  \
//          from users_roles ur           \
//    inner join roles r                  \
//            on ur.role_id = r.id        \
//         where user_id = (              \
//            select id                   \
//             from users                 \
//            where username = ?);        \
//
//jdbcRealm.permissionsQuery=             \               # <3>
//        select p.permission             \
//          from roles_permissions rp     \
//    inner join permissions p            \
//            on rp.permission_id = p.id  \
//         where rp.role_id = (           \
//            select id                   \
//             from roles                 \
//            where label = ?);
//
//jdbcRealm.permissionsLookupEnabled=true                 # <4>
//----
//<1> query to find password for user
//<2> query to find roles for user
//<3> query to find permissions for role
//<4> enable permissions lookup
//
//[WARNING]
//====
//The `permissionsLookupEnabled` is very important, otherwise Shiro just returns an empty list of permissions and your users will have no access to any features(!).
//====
//
//We also should ensure that the passwords are not stored as plain-text:
//
//[source,ini]
//----
//dps = org.apache.shiro.authc.credential.DefaultPasswordService   # <1>
//pm = org.apache.shiro.authc.credential.PasswordMatcher           # <2>
//pm.passwordService = $dps
//jdbcRealm.credentialsMatcher = $pm                               # <3>
//----
//<1> mechanism to encrypts password
//<2> service to match passwords
//<3> instruct JDBC realm to use password matching service when authenticating
//
//
//And finally we need to tell Shiro to use the realm, in the usual fashion:
//
//[source,ini]
//----
//securityManager.realms = $jdbcRealm
//----
//
//Using the above configuration you will also need to setup a `DataSource`.The details vary by servlet container, for example this is link:https://tomcat.apache.org/tomcat-8.0-doc/jndi-datasource-examples-howto.html[how to do the setup on Tomcat 8.0].
//
//[WARNING]
//====
//The name of the `DataSource` can also vary by servlet container; see for example link:http://stackoverflow.com/questions/17441019/how-to-configure-jdbcrealm-to-obtain-its-datasource-from-jndi/23784702#23784702[this StackOverflow answer].
//====


[#enhanced-wildcard-permission]
== Enhanced Wildcard Permission

If using the text-based xref:security:shiro:about.adoc#shiro-ini-realm[IniRealm] or xref:security:shiro-realm-ldap:about.adoc[Apache Isis' LDAP realm], then note that Shiro also allows the string representation of the permissions to be mapped (resolved) to alternative `Permission` instances.
Apache Isis provides its own `IsisPermission` which introduces the concept of a "veto".

A vetoing permission is one that prevents access to a feature, rather than grants it.
This is useful in some situations where most users have access to most features, and only a small number of features are particularly sensitive.
The configuration can therefore be set up to grant fairly broad-brush permissions and then veto permission for the sensitive features for those users that do not have access.

The string representation of the `IsisPermission` uses the following format:

[source,ini]
----
(?<vetoFlag>[!]?)(?:(?<permissionGroup>[^\/]+)[\/])?(?<permission>.+)
----

where:

* the optional `!` prefix indicates this permission is a vetoing permission
* the optional `xxx/` prefix is a permission group that scopes any vetoing permissions
* the remainder of the string is the permission (possibly wild-carded, with :rw as optional suffix)

TIP: Use an online regex tester, eg link:https://regex101.com/[] to get an idea of how this works.

For example:

[source,ini]
----
user_role   = !reg/com.mycompany.myapp.api,\
              !reg/com.mycompany.myapp.webapp.services.admin,\
              reg/* ; \
api_role    = com.mycompany.myapp.api ;\
admin_role = adm/*
----

sets up:

* the `user_role` with access to all permissions except those in `com.mycompany.myapp.api` and `com.mycompany.myapp.webapp.services.admin`
* the `api_role` with access to all permissions in `com.mycompany.myapp.api`
* the `admin_role` with access to everything.

The permission group concept is required to scope the applicability of any veto permission.
This is probably best explained by an example.
Suppose that a user has both `admin_role` and `user_role`; we would want the `admin_role` to trump the vetos of the `user_role`, in other words to give the user access to everything.

:asterisk: *
Because of the permission groups, the two `!reg/...` vetos in `user_role` only veto out selected permissions granted by the ``reg/{asterisk}`` permissions, but they do not veto the permissions granted by a different scope, namely `adm/*`.

The net effect is therefore what we would want: that a user with both `admin_role` and `user_role` would have access to everything, irrespective of those two veto permissions of the `user_role`.

[[permission-resolver-configuration]]
=== Configuration

To configure Apache Isis' extended permission support requires that a custom permission resolver is specified in `shiro.ini` file:

[source,ini]
----
permissionResolver = org.apache.isis.security.shiro.authorization.IsisPermissionResolver
myRealm.permissionResolver = $permissionResolver  # <.>
----
<.> `myRealm` is the handle to the configured realm, eg `$iniRealm` or `$isisLdapRealm` etc.


== Hints and Tips

=== Run-as

This hint shows how to temporarily change the current user as reported by Shiro.
This can be useful to support "Run As", for example.

The heavy lifting is done in `ShiroService`:

[source,java]
----
import org.springframework.stereotype.Service;

@Service
public class ShiroService {

    public void runAs(String userName) {
        SimplePrincipalCollection principals =
            new SimplePrincipalCollection(userName, "jdbcRealm");                       // <1>
        getSubject().runAs(principals);
    }

    public String releaseRunAs() {
        final PrincipalCollection principals = getSubject().releaseRunAs();
        String username = (String)principals.asList().get(0);
        return username;
    }

    public String getUsername() {                                                       // <2>
        String principalAsString = ((String)getSubject().getPrincipal());
        return principalAsString.toLowerCase();
    }

    public String getRealUsername() {                                                   // <3>
        return userService.getUser().getName().toLowerCase();
    }

    public boolean isRunAs() {
        return getSubject().isRunAs();
    }

    private static Subject getSubject() {
        return org.apache.shiro.SecurityUtils.getSubject();
    }

    @Inject
    private UserService userService;
}
----
<1> "jdbcRealm" is realm as configured in Shiro config (shiro.ini).
<2> The username of the currently logged in user (by which permissions are determined).
This could be the user name the real user is running as.
<3> The username of the real currently logged in user.

This could be exposed in the UI using a simple `RunAsService`, for example:

[source,java]
----
@DomainService(nature = NatureOfService.VIEW)
@DomainServiceLayout(menuBar = DomainServiceLayout.MenuBar.TERTIARY)
public class RunAsService {

    public Dashboard runAs(User user) {
        shiroService.runAs(user.getUsername());
        return dashboardService.openDashboard();                    // <1>
    }
    public List<User> choices0RunAs() {
        return ...                                                  // <2>
    }
    public boolean hideRunAs() {
        return shiroService.isRunAs();
    }



    public User releaseRunAs() {
        String username = shiroService.releaseRunAs();
        return usersRepository.findByUsername(username);
    }
    public boolean hideReleaseRunAs() {
        return !shiroService.isRunAs();
    }


    @Inject
    private ShiroService shiroService;
    @Inject
    private UsersRepository usersRepository;
    @Inject
    private DashboardService dashboardService;                      // <1>
}
----
<1> go to the home page (application-specific)
<2> return a list of users to run as


Credits: adapted from link:https://gist.github.com/erikdehair/efa3005440ca982cca41ebe5347e82d8[this gist].

== Caching

To ensure that security operations does not impede performance, Shiro supports caching.
For example, this sets up a simple memory-based cache manager:

[source,ini]
----
memoryCacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager
securityManager.cacheManager = $memoryCacheManager
----

Other implementations can be plugged in; see the Shiro link:http://shiro.apache.org/caching.html[documentation] for further details.

== Further Reading

Shiro provides many other features.
Check out:

* Shiro's documentation page can be found link:http://shiro.apache.org/documentation.html[here].

* community-contributed articles can be found link:http://shiro.apache.org/articles.html[here]. +
+
These include for instance link:http://meri-stuff.blogspot.co.uk/2011/04/apache-shiro-part-2-realms-database-and.html[this interesting article] describing how to perform certificate-based authentication (ie login using Google or Facebook credentials).







