[#jakarta-persistence-Column]
= @Column (jakarta.persistence)

:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

The JPA `@jakarta.persistence.Column` provides metadata describing how JPA should persist the property to a database RDBMS table column (or equivalent concept for other persistence stores).

Apache Causeway also parses and interprets this annotation in order to build up aspects of its metamodel.

[NOTE]
====
Apache Causeway parses the `@Column` annotation from the Java source code; it does not query the JPA metamodel.
This means that it the `@Column` annotation must be used rather than XML metadata.
====

This section identifies which attributes of `@Column` are recognized and used by Apache Causeway.

[#nullability]
== Nullability

The `nullable` attribute is used to specify if a property is mandatory or is optional.

For example:

[source,java]
----
import jakarta.persistence.Column;

public class Customer {

    @Column(nullable=true)
    @Getter @Setter
    private String middleInitial;

    // ...
}
----

Causeway also provides xref:refguide:applib:index/annotation/Property.adoc#optionality[@Property#optionality] attribute.
If both are specified, Apache Causeway will check when it initializes for any contradictions, and will fail-fast with an appropriate error message in the log if there are.

You should also be aware that in the lack of either the `@Column#nullable` or the `@Property#optionality` attributes, that the xref:pjpa:ROOT:about.adoc[JPA/Eclipselink] and Apache Causeway defaults differ.
Apache Causeway rule is straight-forward: properties are assumed to be required.
xref:pjpa:ROOT:about.adoc[JPA/Eclipselink] on the other hand properties are assumed to be optional.
A lack of either annotation may result in a metamodel validation error.

In the vast majority of cases you should be fine just to add the `@Column#nullable` attribute to the getter.
But see the documentation for xref:refguide:applib:index/annotation/Property.adoc#optionality[@Property#optionality] attribute for discussion on one or two minor edge cases.

[#length-for-strings]
== Length for ``String``s

The `length` attribute is used to specify the length of `java.lang.String` property types as they map to `varchar(n)` columns.

For example:

[source,java]
----
import jakarta.persistence.Column;

public class Customer {

    @Column(length=20)
    @Getter @Setter
    private String firstName;

    @Column(length=1, nullable=true)
    @Getter @Setter
    private String middleInitial;

    @Column(length=30)
    @Getter @Setter
    private String lastName;

    // ...
}
----


Apache Causeway also provides xref:refguide:applib:index/annotation/Property.adoc#maxLength[@Property#maxLength] attribute.
If both are specified, Apache Causeway will check when it initializes for any contradictions, and will fail-fast with an appropriate error message in the log if there are.

[#lengthscale-for-bigdecimals]
== Length/scale for ``BigDecimal``s

The `length()` and `scale` attributes are used to infer the precision/scale of `java.math.BigDecimal` property types as they map to `decimal(n,p)` columns.

For example:

[source,java]
----
import jakarta.persistence.Column;
import lombok.*;

public class Customer {

    @Column(length=10, scale=2)
    @Getter @Setter
    private BigDecimal totalOrdersToDate;

    //...
}
----

For ``BigDecimal``s it is also possible to specify the xref:refguide:applib-ant:Digits.adoc[@Digits] annotation, whose form is `@Digits(integer, fraction)`.
There is a subtle difference here: while `@Column#scale()` corresponds to `@Digits#fraction()`, the value of `@Column#length()` (ie the precision) is actually the __sum__ of the `@Digits`' `integer()` and `fraction()` parts.

If both are specified, Apache Causeway will check when it initializes for any contradictions, and will fail-fast with an appropriate error message in the log if there are.

[[rg-ant-hints-and-tips]]
== Hints and Tips

This seems to be a good place to describe some additional common mappings that use `@Column`.
Unlike the sections above, the attributes specified in these hints and tips aren't actually part of Apache Causeway metamodel.

=== Mapping foreign keys

The `name` attribute can be used to override the name of the column.
References to other objects are generally mapped as foreign key columns.
If there are multiple references to a given type, then you will want to override the name that xref:pjpa:ROOT:about.adoc[JPA/Eclipselink] would otherwise default.

For example:

[source,java]
----
import jakarta.persistence.Column;

public class PartyRelationship {

    @Column(name = "fromPartyId", nullable = false)
    @Getter @Setter
    private Party from;

    @Column(name = "toPartyId", nullable = false)
    @Getter @Setter
    private Party to;

    // ...
}
----

=== Mapping ``Blob``s and ``Clob``s

Causeway provides utility classes to help map xref:refguide:applib:index/value/Blob.adoc[Blob]s and xref:refguide:applib:index/value/Clob.adoc[Clob]s.

For example, here's how to map a `Blob`:

[source,java]
----
@AttributeOverrides({
    @AttributeOverride(name="name",    column=@Column(name="attachment_name")),
    @AttributeOverride(name="mimeType",column=@Column(name="attachment_mimeType")),
    @AttributeOverride(name="bytes",   column=@Column(name="attachment_bytes"))
})
@Embedded
private BlobJpaEmbeddable attachment;

@Property()
@PropertyLayout()
public Blob getPdf() {
  return BlobJpaEmbeddable.toBlob(pdf);
}
public void setPdf(final Blob pdf) {
  this.pdf = BlobJpaEmbeddable.fromBlob(pdf);
}
----

And here's how to map a `Clob`:

[source,java]
----
@AttributeOverrides({
    @AttributeOverride(name="name",    column=@Column(name="doc_name")),
    @AttributeOverride(name="mimeType",column=@Column(name="doc_mimeType")),
    @AttributeOverride(name="bytes",   column=@Column(name="doc_bytes"))
})
@Getter @Setter
private ClobJpaEmbeddable doc;

@Property()
@PropertyLayout()
public Clob getDoc() {
  return ClobJpaEmbeddable.toClob(doc);
}
public void setDoc(final Clob doc) {
  this.doc = ClobJpaEmbeddable.fromClob(doc);
}
----


== See Also

- link:https://jakarta.ee/specifications/persistence/3.0/apidocs/jakarta.persistence/jakarta/persistence/Column[@Column] (JPA API javadoc)
