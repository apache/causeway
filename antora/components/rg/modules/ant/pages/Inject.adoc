= `@Inject` (`javax`)
:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
include::_attributes.adoc[]



Apache Isis automatically injects domain services into other domain services and also into domain objects and view models.
In fact, it also injects domain services into xref:ug:tst:ugtst.adoc#_ugtst_integ-test-support[integration tests] and xref:ug:tst:ugtst.adoc#_ugtst_fixture-scripts[fixture scripts].

[NOTE]
====
One omission: Apache Isis (currently) does not inject services into `o.a.i.applib.spec.Specification` instances (as used by xref:rg:ant:rgant.adoc#_rgant-Property_mustSatisfy[`@Property#mustSatisfy()`] and xref:rg:ant:rgant.adoc#_rgant-Parameter_mustSatisfy[`@Parameter#mustSatisfy()`] annotations.
====

Apache Isis supports several syntaxes for injecting domain services.
The simplest uses the `@javax.inject.Inject` annotation on the field, as defined in link:https://jcp.org/en/jsr/detail?id=330[JSR-330].

For example:

[source,java]
----
public class Customer {
    public List<Order> findRecentOrders() {    // <1>
        return orders.recentOrdersFor(this);
    }
    @javax.inject.Inject
    OrderRepository orders;                    // <2>
}
----
<1> an alternative implementation would be to implement `findRecentOrders()` as a xref:ug:fun:ugfun.adoc#_ugfun_how-tos_contributed-members[contributed action].
<2> we recommend default (rather than `private`) visibility so that unit tests can easily mock out the service



== Alternative syntaxes

Apache Isis also supports setter-based injection:

[source,java]
----
public class Customer {
    ...
    public void setOrderRepository(OrderRepository orderRepository) { ... }
}
----

and also supports an additional syntax of using `inject...` as the prefix:

[source,java]
----
public class Customer {
    ...
    public void injectOrderRepository(OrderRepository orderRepository) { ... }
}
----

Generally we recommend using `@javax.inject.Inject`; it involves less code, and is more immediately familiar to most Java developers.



== Injecting collection of services

It can sometimes be useful to have declared multiple implementations of a particular domain service.
For example, you may have a module that defines an SPI service, where multiple other modules might provide implementations of that SPI (akin to the chain of responsibility pattern).
To support these scenarios, it is possible to annotate a `List` or `Collection`.

For example, suppose that we provide an SPI service to veto the placing of ``Order``s for certain ``Customer``s:

[source,java]
----
public interface CustomerOrderAdvisorService {
    @Programmatic
    String vetoPlaceOrder(Customer c);
----

We could then inject a collection of these services:

[source,java]
----
public class Customer {
    public Order placeOrder(Product p, int quantity) { ... }
    public String disablePlaceOrder(Product p, int quantity) {
        for(CustomerOrderAdvisorService advisor: advisors) {
            String reason = advisor.vetoPlaceOrder(this);
            if(reason != null) { return reason; }
        }
        return null;
    }
    @Inject
    Collection<CustomerOrderAdvisorService> advisors;       // <1>
}
----
<1> inject a collection of the services.

[NOTE]
====
An alternative and almost equivalent design would be to publish an event using the xref:rg:svc:rgsvc.adoc#_rgsvc_core-domain-api_EventBusService[`EventBusService`] and implement the domain services as subscribers to the event.
This alternative design is used in the (non-ASF) link:http://platform.incode.org[Incode Platform^]'s poly module, for example.
====





== Manually injecting services

Apache Isis performs dependency injection when domain entities are recreated.
It will also perform dependency injection if an object is created through the xref:rg:svc:rgsvc.adoc#_rgsvc_core-domain-api_FactoryService[`FactoryService`] or xref:rg:svc:rgsvc.adoc#_rgsvc_core-domain-api_RepositoryService[`RepositoryService`].

For example, to create a new (transient) domain object, the idiom is:

[source,java]
----
Customer cust = repositoryService.instantiate(Customer.class);  <1>
// initialize state of "cust"
repositoryService.persist(cust);
----

View models are created identically:

[source,java]
----
ToDoAppDashboard dashboard = repositoryService.instantiate(ToDoAppDashboard.class);
----


If you prefer, though, you can simply instantiate domain objects using "new" and then inject domain services manually using xref:rg:svc:rgsvc.adoc#_rgsvc_core-domain-api_ServiceRegistry[`ServiceRegistry`]:


[source,java]
----
Customer cust = new Customer();
serviceRegistry.injectServicesInto(cust);
// initialize state of "cust"
repositoryService.persist(cust);
----



[NOTE]
====
Note that using either `FactoryService#instantiate(...)` or `RepositoryService#instantiate(...)` will also automatically initialize all fields to their default values, and will also fire a "created" lifecycle event.

Neither of these are particularly useful (and indeed can sometimes be rather confusing) so you may well wish to standardize on using `injectServicesInto(...)` throughout.
====
