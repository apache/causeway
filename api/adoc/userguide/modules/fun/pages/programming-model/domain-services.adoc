= Domain Services

:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:page-partial:


This section looks at the programming model for writing your own domain services.

== Nature of Service

Apache Isis uses Spring Boot to instantiate and manage the dependency injection of domain services.
The vast majority of these are singleton (application) scoped; a smaller number are request scoped (using the xref:refguide:applib-ant:IsisSessionScope.adoc[`@IsisSessionScope`] annotation).

Accordingly, all domain services are annotated or meta-annotated using Spring's link:https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html[`@Component`] annotation.

For domain services to be visible in the Apache Isis UI, they must be annotated with xref:refguide:applib-ant:DomainService.adoc[`@DomainService`].
Its xref:refguide:applib-ant:DomainService.adoc#nature[`#nature()`] attribute is either:

* `VIEW` (the default if not specified)
+
which indicates that the actions should appear on the menu of the xref:vw:ROOT:about.adoc[Wicket viewer], and as top-level actions for the REST API provided by the xref:vro:ROOT:about.adoc[Restful Objects viewer].

* `REST`
+
which indicates that the actions should appear in the REST API provided by the xref:vro:ROOT:about.adoc[Restful Objects viewer], but not rendered by the xref:vw:ROOT:about.adoc[Wicket viewer].

It's also possible to define a "programmatic" domain service, meaning one that is instantiated and injected by Spring Boot, but is not visible in the UI or REST API.
For example, the xref:subdomains:docx:about.adoc[Docx Library] provides a domain service that performs mail merge using MS Word, but this domain service is not intended to appear in the UI.
Such programmatic services are usually annotated with Spring's link:https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html[`@Service`] annotation or link:https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html[`@Repository`].

== Repository and Factory

The repository/factory uses an injected xref:refguide:applib-svc:RepositoryService.adoc[`RepositoryService`] to both instantiate new objects and to query the database for existing objects of a given entity type.
Generally these services are not visible in UI, and so are annotated with link:https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html[`@Repository`]

For example:

[source,java]
----
@Repository                                                     // <.>
@lombok.RequiredArgsConstructor(onConstructor_ = {@Inject} )    // <.>
public CustomerRepository {

    private final RepositoryService repositoryService;

    public List<Customer> findByName(String name) {
        return repositoryService.allMatches(                    // <.>
                new QueryDefault<>(Customer.class,
                            "findByName", "name", name);
    }

    public Customer newCustomer(...) {
        Customer Customer =
            repositoryService.detachedEntity(Customer.class);   // <.>
        ...
        return repositoryService.persistAndFlush(Customer);     // <.>
    }

    public List<Customer> allCustomers() {                      // <.>
        return repositoryService.allInstances(Customer.class);
    }
}
----

<.> Detected and managed by Spring Boot.
<.> Lombok annotation for dependency injection of xref:refguide:applib-svc:RepositoryService.adoc[`RepositoryService`] through generated constructor.
<.> uses injected `RepositoryService` to query via JDOQL.
<.> uses injected `RepositoryService` to instantiate a not-yet-persisted domain entity ...
<.> \... and then save into the database a new `Customer` instance.
<.> Returns all instances (useful for prototyping, probably not for production).

There is no need to annotate the actions; they are implicitly hidden because of the domain service's nature.

[TIP]
====
JDO/Datanucleus also supports link:http://www.datanucleus.org:15080/products/accessplatform_5_2/jdo/query.html#jdoql_typed[type-safe queries].
These can be executed through the xref:pjdo:ROOT:services/IsisJdoSupport.adoc[`IsisJdoSupport`] domain service.
====

== Menu

Menu services provide actions to be rendered on the menu.

For the xref:vw:ROOT:about.adoc[Wicket Viewer], each service's actions appear as a collection of menu items of a named menu, and this menu is on one of the three menu bars provided by the Wicket viewer.
Although these can be organised using annotations, it's usually easier to use a xref:vw:ROOT:menubars-layout.adoc#file-based[file-based layout file] (`menubars.layout.xml`).

For the xref:vro:ROOT:about.adoc[Restful Objects Viewer], all menu services are shown in the services representation.

[source,java]
----
@DomainService(nature = NatureOfService.VIEW)                   // <.>
@lombok.RequiredArgsConstructor(onConstructor_ = {@Inject} )    // <.>
public class Customers {

    @Inject
    protected final CustomerRepository customerRepository;      // <.>

    @Action(semantics = SemanticsOf.SAFE)
    @ActionLayout(bookmarking = BookmarkPolicy.AS_ROOT)
    public List<Customer> findByName(                           // <.>
            @ParameterLayout(named="Name")                      // <.>
            final String name ) {
        return customerRepository.findByName(name);             // <.>
    }

    @Action(semantics = SemanticsOf.NON_IDEMPOTENT)
    public Customer newCustomer(...) {
        return customerRepository.newCustomer(...);
    }

    @Action( semantics = SemanticsOf.SAFE,
             restrictTo = RestrictTo.PROTOTYPING )              // <.>
    public List<Customer> listAll() {
        return customerRepository.listAll();
    }
}
----

<.> Identify the class as a domain service, to render in the menu.

<.> Rendered in the UI as a "Find By Name" menu item underneath the "Customers" menu.

<.> The xref:refguide:applib-ant:ParameterLayout.adoc[`@ParameterLayout`] provides metadata for the parameter itself, in this case its name.
+
[TIP]
====
There's no need to name the action parameters if the code is compiled using the `-parameters` flag to the Java compiler (javac); the framework will then use the name of the parameter itself.
====

<.> the action implementation delegates to an injected repository.
The framework can inject into not just other domain services but will also automatically into domain entities and view models.
There is further discussion of service injection xref:userguide:fun:programming-model.adoc#inject-services[below].

<.> xref:refguide:applib-ant:Action.adoc#restrictTo[Prototype] actions are rendered only in prototyping mode.
A "list all" action such as this can be useful when exploring the domain with a small dataset.

<.> Menu services typically delegate to an underlying repository/ies specific to the domain (rather than use `RepositoryService` directly, for example).

Whether you separate out menu services from repository services is to some extent a matter of style.
One perspective is that these two closely related domain services nevertheless have different responsibilities, and so could be kept separate.
An alternative perspective is that the duplication is just unnecessary boilerplate, and conflicts with the naked objects philosophy.

== Event Subscribers

Domain services acting as event subscribers can subscribe to xref:userguide:fun:building-blocks.adoc#lifecycle-events[lifecycle] events, influencing the rendering and behaviour of other objects.
Behind the scenes this uses Spring's (in-memory) link:https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-functionality-events-annotation[event bus].

[source,java]
----
import org.springframework.context.event.EventListener;

@Service                                                        // <.>
@lombok.RequiredArgsConstructor(onConstructor_ = {@Inject} )
public class OnCustomerDeletedCascadeDeleteOrders {

    @Inject
    private final OrderRepository orderRepository;

    @EventListener(Customer.DeletedEvent.class)                 // <.>
    public void on(final Customer.DeletedEvent ev) {            // <.>
        Customer customer = ev.getSource();
        orderRepository.delete(customer);
    }
}
----

<.> subscriptions do not appear in the UI at all

<.> use Spring Framework's link:https://javadoc.io/doc/org.springframework/spring-context/latest/org/springframework/context/event/EventListener.html[`@EventListener`]

<.> the parameter type of the method corresponds to the event emitted on the event bus.
The actual method name does not matter (though it must have `public` visibility).

== Scoped services

By default all domain services are application-scoped, in other words singletons.
Such domain services are required to be thread-safe, usually satisfied by being intrinsically stateless.

Sometimes though a service's lifetime is applicable only to a single (http) request.
The framework has a number of such services, including a xref:refguide:applib-svc:Scratchpad.adoc[`Scratchpad`] service (to share adhoc data between methods), and xref:refguide:applib-svc:QueryResultsCache.adoc[`QueryResultsCache`], which as its name suggests will cache query results.
Such services _do_ hold state, but that state is scoped per (possibly concurrent) request and should be removed afterwards.

The requirement for request-scoped services is supported using Apache Isis' own xref:refguide:applib-ant:IsisSessionScope.adoc[`@IsisSessionScope`] annotation (named because a short-lived `IsisSession` is created for each request).
This is used by the framework services and can also be used for user-defined services.

For example:

[source,java]
----
@Service
@IsisSessionScope
public class MyService {
    ...
    public void doSomething() { ... }
}
----

Unlike application-scoped services, these request-scoped services must be injected using a slightly different idiom (borrowed from CDI), using a `javax.inject.Provider`.
For example:

[source,java]
----
import javax.inject.Provider;

public class SomeClient {
    ...
    @Inject
    Provider<MyService> myServiceProvider;  // <.>

    public void someMethod() {
        myServiceProvider.get()             // <.>
                         .doSomething();
}
----
<.> Inject using `Provider`
<.> Obtain an instance using `Provider#get()`


== Registering

The easiest way to register domain services with the framework is to use Spring's link:http://localhost:5000[`@ComponentScan`] annotation on an owning link:https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html[`@Configuration`].

The xref:docs:starters:simpleapp.adoc[simpleapp starter apps] illustrates the idiom:

* for each Maven module, we have


[source,ini]
----
public class MyAppManifest implements AppManifest {
    public List<Class<?>> getModules() {
        return Arrays.asList(
                TodoAppDomainModule.class,
                TodoAppFixtureModule.class,
                TodoAppAppModule.class,
                org.isisaddons.module.audit.AuditModule.class);
    }
    ...
}
----

will load all services in the packages underneath the four modules listed.

Examples of framework-provided services (as defined in the applib) include clock, auditing, publishing, exception handling, view model support, snapshots/mementos, and user/application settings management; see the xref:refguide:applib-svc:about.adoc[domain services] reference guide for further details.

== Initialization

WARNING: TODO: v2: support for init with a Map is no longer supported, I suspect...?
Instead, can x-ref Spring's strongly typed configuration beans

Services can optionally declare lifecycle callbacks to initialize them (when the app is deployed) and to shut them down (when the app is undeployed).

An Apache Isis session _is_ available when initialization occurs (so services can interact with the object store, for example).

The framework will call any `public` method annotated with xref:refguide:applib-ant:PostConstruct.adoc[`@PostConstruct`] with either no arguments of an argument of type `Map<String,String>`.
In the latter case, the framework passes in the configuration.

Shutdown is similar; the framework will call any method annotated with xref:refguide:applib-ant:PreDestroy.adoc[`@PreDestroy`].



